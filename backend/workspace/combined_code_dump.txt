// File: workspace/TodoApp/vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import { VitePWA } from "vite-plugin-pwa";

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      devOptions: {
        enabled: true,
        type: "module",
      },
      registerType: "autoUpdate",
      workbox: {
        // Use runtime caching for dynamic imports
        runtimeCaching: [
          {
            urlPattern: ({ request }) =>
              request.destination === "script" ||
              request.destination === "style" ||
              request.destination === "font" ||
              request.destination === "worker",
            handler: "CacheFirst",
            options: {
              cacheName: "dynamic-resources",
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 30 * 24 * 60 * 60,
              },
            },
          },
          {
            urlPattern: ({ request }) => request.mode === "navigate",
            handler: "NetworkFirst",
            options: {
              cacheName: "documents",
              networkTimeoutSeconds: 10,
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 30 * 24 * 60 * 60,
              },
            },
          },
          {
            urlPattern: ({ request }) => request.destination === "image",
            handler: "CacheFirst",
            options: {
              cacheName: "images",
              expiration: {
                maxEntries: 50,
                maxAgeSeconds: 30 * 24 * 60 * 60,
              },
            },
          },
        ],
      },
      includeAssets: ["**/*"],
      manifest: {
        theme_color: "#7764E8",
        background_color: "#171D34",
        display: "standalone",
        scope: "/",
        start_url: "/",
        short_name: "Todo App",
        description:
          "Todo app with many features, including local storage, sharing tasks via link and more! Made by github.com/maciekt07",
        name: "Todo App",
        icons: [
          {
            src: "/logo192.png",
            sizes: "192x192",
            type: "image/png",
          },
          {
            src: "/logo256.png",
            sizes: "256x256",
            type: "image/png",
          },
          {
            src: "/logo384.png",
            sizes: "384x384",
            type: "image/png",
          },
          {
            src: "/logo512.png",
            sizes: "512x512",
            type: "image/png",
          },
          {
            src: "pwa/logoMaskable.png",
            sizes: "256x256",
            type: "image/png",
            purpose: "maskable",
          },
        ],
        shortcuts: [
          {
            name: "Add Task",
            description: "Add Task",
            url: "/add",
            icons: [
              {
                src: "pwa/add.png",
                sizes: "192x192",
                type: "image/png",
              },
            ],
          },
          {
            name: "Categories",
            description: "Task Categories",
            url: "/categories",
            icons: [
              {
                src: "pwa/categories.png",
                sizes: "192x192",
                type: "image/png",
              },
            ],
          },
          {
            name: "Transfer",
            description: "Import or Export Task",
            url: "/transfer",
            icons: [
              {
                src: "pwa/transfer.png",
                sizes: "192x192",
                type: "image/png",
              },
            ],
          },
          {
            name: "Purge",
            description: "Purge Tasks",
            url: "/purge",
            icons: [
              {
                src: "pwa/purge.png",
                sizes: "192x192",
                type: "image/png",
              },
            ],
          },
          {
            name: "Profile",
            description: "User Profile",
            url: "/user",
            icons: [
              {
                src: "pwa/profile.png",
                sizes: "192x192",
                type: "image/png",
              },
            ],
          },
        ],
        screenshots: [
          {
            src: "pwa/wideScreenshot1.png",
            sizes: "1460x959",
            form_factor: "wide",
          },
          {
            src: "pwa/wideScreenshot2.png",
            sizes: "1460x959",
            form_factor: "wide",
          },
          {
            src: "pwa/narrowScreenshot1.png",
            sizes: "1170x2532",
            form_factor: "narrow",
          },
          {
            src: "pwa/narrowScreenshot2.png",
            sizes: "1170x2532",
            form_factor: "narrow",
          },
        ],
      },
    }),
  ],
});


// File: workspace/TodoApp/src/App.tsx
import { ThemeProvider as EmotionTheme } from "@emotion/react";
import { DataObjectRounded } from "@mui/icons-material";
import { ThemeProvider, type Theme } from "@mui/material";
import { useCallback, useContext, useEffect } from "react";
import ErrorBoundary from "./components/ErrorBoundary";
import { defaultUser } from "./constants/defaultUser";
import { UserContext } from "./contexts/UserContext";
import { useSystemTheme } from "./hooks/useSystemTheme";
import MainLayout from "./layouts/MainLayout";
import AppRouter from "./router";
import { GlobalStyles } from "./styles";
import { getFontColor, showToast } from "./utils";
import { CustomToaster } from "./components/Toaster";
import { ColorPalette } from "./theme/themeConfig";
import { Themes, createCustomTheme } from "./theme/theme";

function App() {
  const { user, setUser } = useContext(UserContext);
  const systemTheme = useSystemTheme();

  // Initialize user properties if they are undefined
  // this allows to add new properties to the user object without error
  useEffect(() => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateNestedProperties = (userObject: any, defaultObject: any) => {
      if (!userObject) {
        return defaultObject;
      }

      Object.keys(defaultObject).forEach((key) => {
        // Skip 'categories' key
        if (key === "categories") {
          return;
        }
        // Check if userObject has a different colorList array than defaultObject
        if (
          key === "colorList" &&
          user.colorList &&
          !defaultUser.colorList.every((element, index) => element === user.colorList[index])
        ) {
          return;
        }

        const userValue = userObject[key];
        const defaultValue = defaultObject[key];

        if (typeof defaultValue === "object" && defaultValue !== null) {
          // If the property is an object, recursively update nested properties
          userObject[key] = updateNestedProperties(userValue, defaultValue);
        } else if (userValue === undefined) {
          // Update only if the property is missing in user
          userObject[key] = defaultValue;
          // Notify users about update
          showToast(
            <div>
              Added new property to user object{" "}
              <i translate="no">
                {key.toString()}: {userObject[key].toString()}
              </i>
            </div>,
            {
              duration: 6000,
              icon: <DataObjectRounded />,
              disableVibrate: true,
            }
          );
        }
      });

      return userObject;
    };

    // Update user with default values for all properties, including nested ones
    setUser((prevUser) => {
      // Make sure not to update if user hasn't changed
      if (
        JSON.stringify(prevUser) !==
        JSON.stringify(updateNestedProperties({ ...prevUser }, defaultUser))
      ) {
        return updateNestedProperties({ ...prevUser }, defaultUser);
      }
      return prevUser;
    });
  }, [setUser, user.colorList]);

  // This useEffect displays an native application badge count (for PWA) based on the number of tasks that are not done.
  // https://developer.mozilla.org/en-US/docs/Web/API/Badging_API
  useEffect(() => {
    const setBadge = async (count: number) => {
      if ("setAppBadge" in navigator) {
        try {
          await navigator.setAppBadge(count);
        } catch (error) {
          console.error("Failed to set app badge:", error);
        }
      }
    };

    const clearBadge = async () => {
      if ("clearAppBadge" in navigator) {
        try {
          await navigator.clearAppBadge();
        } catch (error) {
          console.error("Failed to clear app badge:", error);
        }
      }
    };
    // Function to display the application badge
    const displayAppBadge = async () => {
      if (user.settings[0].appBadge === true) {
        // Request permission for notifications
        if ((await Notification.requestPermission()) === "granted") {
          // Calculate the number of incomplete tasks
          const incompleteTasksCount = user.tasks.filter((task) => !task.done).length;
          // Update the app badge count if the value is a valid number
          if (!isNaN(incompleteTasksCount)) {
            setBadge(incompleteTasksCount);
          }
        }
      } else {
        clearBadge();
      }
    };
    // Check if the browser supports setting the app badge
    if ("setAppBadge" in navigator) {
      displayAppBadge();
    }
  }, [setUser, user.settings, user.tasks]);

  const getMuiTheme = useCallback((): Theme => {
    if (systemTheme === "unknown") {
      return Themes[0].MuiTheme;
    }
    if (user.theme === "system") {
      return systemTheme === "dark" ? Themes[0].MuiTheme : Themes[1].MuiTheme;
    }
    const selectedTheme = Themes.find((theme) => theme.name === user.theme);
    return selectedTheme ? selectedTheme.MuiTheme : Themes[0].MuiTheme;
  }, [systemTheme, user.theme]);

  const isDarkMode = (): boolean => {
    switch (user.darkmode) {
      case "light":
        return false;
      case "dark":
        return true;
      case "system":
        return systemTheme === "dark";
      case "auto":
        return getFontColor(getMuiTheme().palette.secondary.main) === ColorPalette.fontLight;
      default:
        return false;
    }
  };

  // Update the theme color meta tag in the document's head based on the user's selected theme.
  useEffect(() => {
    document
      .querySelector("meta[name=theme-color]")
      ?.setAttribute("content", getMuiTheme().palette.secondary.main);
  }, [user.theme, getMuiTheme]);

  return (
    <ThemeProvider
      theme={createCustomTheme(
        getMuiTheme().palette.primary.main,
        getMuiTheme().palette.secondary.main,
        isDarkMode() ? "dark" : "light"
      )}
    >
      <EmotionTheme
        theme={{
          primary: getMuiTheme().palette.primary.main,
          secondary: getMuiTheme().palette.secondary.main,
          darkmode: isDarkMode(),
        }}
      >
        <GlobalStyles />
        <CustomToaster />
        <ErrorBoundary>
          <MainLayout>
            <AppRouter />
          </MainLayout>
        </ErrorBoundary>
      </EmotionTheme>
    </ThemeProvider>
  );
}

export default App;


// File: workspace/TodoApp/src/main.tsx
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import { BrowserRouter } from "react-router-dom";
import { initColors } from "ntc-ts";
import { ORIGINAL_COLORS } from "ntc-ts";
import { UserContextProvider } from "./contexts/UserProvider.tsx";

// initialize ntc colors
initColors(ORIGINAL_COLORS);

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <BrowserRouter>
    <UserContextProvider>
      <App />
    </UserContextProvider>
  </BrowserRouter>
);


// File: workspace/TodoApp/src/router.tsx
import { ReactElement, Suspense, lazy } from "react";
import { Route, Routes } from "react-router-dom";
import { Loading } from "./components";

const Home = lazy(() => import("./pages/Home"));
const TaskDetails = lazy(() => import("./pages/TaskDetails"));
const SharePage = lazy(() => import("./pages/Share"));
const AddTask = lazy(() => import("./pages/AddTask"));
const UserProfile = lazy(() => import("./pages/UserProfile"));
const ImportExport = lazy(() => import("./pages/ImportExport"));
const Categories = lazy(() => import("./pages/Categories"));
const Purge = lazy(() => import("./pages/Purge"));
const NotFound = lazy(() => import("./pages/NotFound"));

const AppRouter = (): ReactElement => {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/task/:id" element={<TaskDetails />} />
        <Route path="/share" element={<SharePage />} />
        <Route path="/add" element={<AddTask />} />
        <Route path="/user" element={<UserProfile />} />
        <Route path="/transfer" element={<ImportExport />} />
        <Route path="/categories" element={<Categories />} />
        <Route path="/purge" element={<Purge />} />
        <Route path="/loading" element={<Loading />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </Suspense>
  );
};

export default AppRouter;


// File: workspace/TodoApp/src/vite-env.d.ts
/// <reference types="vite/client" />


// File: workspace/TodoApp/src/types/github.ts
export interface GitHubInfoResponse {
  repoData: GitHubRepoResponse;
  branchData: GitHubBranchResponse;
}

// https://transform.tools/json-to-typescript

/**
 * Interface representing the response format for a GitHub repository.
 */
export interface GitHubRepoResponse {
  id: number;
  node_id: string;
  name: string;
  full_name: string;
  private: boolean;
  owner: Owner;
  html_url: string;
  description: string;
  fork: boolean;
  url: string;
  forks_url: string;
  keys_url: string;
  collaborators_url: string;
  teams_url: string;
  hooks_url: string;
  issue_events_url: string;
  events_url: string;
  assignees_url: string;
  branches_url: string;
  tags_url: string;
  blobs_url: string;
  git_tags_url: string;
  git_refs_url: string;
  trees_url: string;
  statuses_url: string;
  languages_url: string;
  stargazers_url: string;
  contributors_url: string;
  subscribers_url: string;
  subscription_url: string;
  commits_url: string;
  git_commits_url: string;
  comments_url: string;
  issue_comment_url: string;
  contents_url: string;
  compare_url: string;
  merges_url: string;
  archive_url: string;
  downloads_url: string;
  issues_url: string;
  pulls_url: string;
  milestones_url: string;
  notifications_url: string;
  labels_url: string;
  releases_url: string;
  deployments_url: string;
  created_at: string;
  updated_at: string;
  pushed_at: string;
  git_url: string;
  ssh_url: string;
  clone_url: string;
  svn_url: string;
  homepage: string;
  size: number;
  stargazers_count: number;
  watchers_count: number;
  language: string;
  has_issues: boolean;
  has_projects: boolean;
  has_downloads: boolean;
  has_wiki: boolean;
  has_pages: boolean;
  has_discussions: boolean;
  forks_count: number;
  mirror_url: unknown;
  archived: boolean;
  disabled: boolean;
  open_issues_count: number;
  license: License;
  allow_forking: boolean;
  is_template: boolean;
  web_commit_signoff_required: boolean;
  topics: string[];
  visibility: string;
  forks: number;
  open_issues: number;
  watchers: number;
  default_branch: string;
  network_count: number;
  subscribers_count: number;
}
/**
 * Interface representing the response format for a GitHub branch.
 */
export interface GitHubBranchResponse {
  name: string;
  commit: Commit;
  _links: Links;
  protected: boolean;
  protection: Protection;
  protection_url: string;
}

interface Owner {
  login: string;
  id: number;
  node_id: string;
  avatar_url: string;
  gravatar_id: string;
  url: string;
  html_url: string;
  followers_url: string;
  following_url: string;
  gists_url: string;
  starred_url: string;
  subscriptions_url: string;
  organizations_url: string;
  repos_url: string;
  events_url: string;
  received_events_url: string;
  type: string;
  site_admin: boolean;
}
interface Tree {
  sha: string;
  url: string;
}
interface License {
  key: string;
  name: string;
  spdx_id: string;
  url: string;
  node_id: string;
}

interface Commit extends Tree {
  node_id: string;
  commit: Commit2;
  html_url: string;
  comments_url: string;
  author: Owner;
  committer: Owner;
  parents: Parent[];
}

interface Commit2 {
  author: Author;
  committer: Author;
  message: string;
  tree: Tree;
  url: string;
  comment_count: number;
  verification: Verification;
}

interface Author {
  name: string;
  email: string;
  date: string;
}

interface Verification {
  verified: boolean;
  reason: string;
  signature: unknown;
  payload: unknown;
}

interface Parent extends Tree {
  html_url: string;
}

interface Links {
  self: string;
  html: string;
}

interface Protection {
  enabled: boolean;
  required_status_checks: RequiredStatusChecks;
}

interface RequiredStatusChecks {
  enforcement_level: string;
  contexts: unknown[];
  checks: unknown[];
}


// File: workspace/TodoApp/src/types/user.ts
import type { EmojiStyle } from "emoji-picker-react";

/**
 * Represents a universally unique identifier.
 */
export type UUID = ReturnType<typeof crypto.randomUUID>;

export type DarkModeOptions = "system" | "auto" | "light" | "dark";

/**
 * Represents a user in the application.
 */
export interface User {
  name: string | null;
  createdAt: Date;
  profilePicture: string | null;
  emojisStyle: EmojiStyle;
  tasks: Task[];
  categories: Category[];
  colorList: string[];
  settings: AppSettings[];
  theme: string;
  darkmode: DarkModeOptions;
}

/**
 * Represents a task in the application.
 */
export interface Task {
  id: UUID;
  done: boolean;
  pinned: boolean;
  name: string;
  description?: string;
  emoji?: string;
  color: string;
  date: Date;
  deadline?: Date;
  category?: Category[];
  lastSave?: Date;
  sharedBy?: string;
}

// export type Emoji = Omit<
//   EmojiClickData,
//   "activeSkinTone" | "names" | "unifiedWithoutSkinTone" | "getImageUrl"
// > & {
//   name: string;
// };

// export type Emoji = Pick<EmojiClickData, "unified" | "emoji" | "names">;

/**
 * Represents a category in the application.
 */
export interface Category {
  id: UUID;
  name: string;
  emoji?: string;
  color: string;
}

/**
 * Represents application settings for the user.
 */
export interface AppSettings {
  enableCategories: boolean;
  doneToBottom: boolean;
  enableGlow: boolean;
  simpleEmojiPicker: boolean;
  enableReadAloud: boolean;
  appBadge: boolean;
  voice: string;
  voiceVolume: number;
}


// File: workspace/TodoApp/src/types/emotion.d.ts
import "@emotion/react";
declare module "@emotion/react" {
  export interface Theme {
    /**
     * Emotion Primary color
     */
    primary: string;
    /**
     * Emotion Background color
     */
    secondary: string;
    /**
     * Emotion darkmode
     */
    darkmode: boolean;
  }
}


// File: workspace/TodoApp/src/types/ntc-ts.d.ts
interface FORMATTED_COLOR {
  exactMatch: boolean;
  name: string;
  rgb: string | null;
}
type COLOR = Array<string | number>;
declare module "ntc-ts" {
  export function getColorName(color: string): FORMATTED_COLOR;
  export function getRGB(color: string, divider = 1): number[];
  export function getHSL(color: string): number[];
  export function initColors(_colors: COLOR[]): void;
  export const ORIGINAL_COLORS: COLOR[];
}


// File: workspace/TodoApp/src/contexts/UserContext.tsx
import { createContext } from "react";
import type { User } from "../types/user";
import { defaultUser } from "../constants/defaultUser";

interface UserProps {
  user: User; // User data
  setUser: React.Dispatch<React.SetStateAction<User>>; // Function to update user data
}

export const UserContext = createContext<UserProps>({ user: defaultUser, setUser: () => {} });


// File: workspace/TodoApp/src/contexts/UserProvider.tsx
import { defaultUser } from "../constants/defaultUser";
import { useStorageState } from "../hooks/useStorageState";
import { User } from "../types/user";
import { UserContext } from "./UserContext";

export const UserContextProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useStorageState<User>(defaultUser, "user");
  return <UserContext.Provider value={{ user, setUser }}>{children}</UserContext.Provider>;
};


// File: workspace/TodoApp/src/contexts/TaskProvider.tsx
import { ReactNode, useState } from "react";
import { UUID } from "../types/user";
import { useStorageState } from "../hooks/useStorageState";
import { HighlightedText } from "../components/tasks/tasks.styled";
import { useResponsiveDisplay } from "../hooks/useResponsiveDisplay";
import { TaskContext, TaskContextType } from "./TaskContext";

export const TaskProvider = ({ children }: { children: ReactNode }) => {
  const [selectedTaskId, setSelectedTaskId] = useState<UUID | null>(null);
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [anchorPosition, setAnchorPosition] = useState<{ top: number; left: number } | null>(null);
  const [expandedTasks, setExpandedTasks] = useState<Set<UUID>>(new Set());
  const [multipleSelectedTasks, setMultipleSelectedTasks] = useStorageState<UUID[]>(
    [],
    "selectedTasks",
    "sessionStorage"
  );
  const [search, setSearch] = useStorageState<string>("", "search", "sessionStorage");
  const [editModalOpen, setEditModalOpen] = useState<boolean>(false);

  const [deleteDialogOpen, setDeleteDialogOpen] = useState<boolean>(false);

  const toggleShowMore = (taskId: UUID) => {
    setExpandedTasks((prevExpandedTasks) => {
      const newSet = new Set(prevExpandedTasks);
      newSet.has(taskId) ? newSet.delete(taskId) : newSet.add(taskId);
      return newSet;
    });
  };

  const handleSelectTask = (taskId: UUID) => {
    setAnchorEl(null);
    setMultipleSelectedTasks((prevSelectedTaskIds) => {
      if (prevSelectedTaskIds.includes(taskId)) {
        // Deselect the task if already selected
        return prevSelectedTaskIds.filter((id) => id !== taskId);
      } else {
        // Select the task if not selected
        return [...prevSelectedTaskIds, taskId];
      }
    });
  };

  const highlightMatchingText = (text: string): ReactNode => {
    if (!search) {
      return text;
    }

    const parts = text.split(new RegExp(`(${search})`, "gi"));
    return parts.map((part, index) =>
      part.toLowerCase() === search.toLowerCase() ? (
        <HighlightedText key={index}>{part}</HighlightedText>
      ) : (
        part
      )
    );
  };
  const handleDeleteTask = () => {
    // Opens the delete task dialog
    if (selectedTaskId) {
      setDeleteDialogOpen(true);
    }
  };

  const isMobile = useResponsiveDisplay();

  const handleCloseMoreMenu = () => {
    setAnchorEl(null);
    document.body.style.overflow = "visible";
    if (selectedTaskId && !isMobile && expandedTasks.has(selectedTaskId)) {
      toggleShowMore(selectedTaskId);
    }
  };

  const contextValue: TaskContextType = {
    selectedTaskId,
    setSelectedTaskId,
    anchorEl,
    setAnchorEl,
    anchorPosition,
    setAnchorPosition,
    expandedTasks,
    setExpandedTasks,
    toggleShowMore,
    search,
    setSearch,
    highlightMatchingText,
    multipleSelectedTasks,
    setMultipleSelectedTasks,
    handleSelectTask,
    editModalOpen,
    setEditModalOpen,
    handleDeleteTask,
    deleteDialogOpen,
    setDeleteDialogOpen,
    handleCloseMoreMenu,
  };

  return <TaskContext.Provider value={contextValue}>{children}</TaskContext.Provider>;
};


// File: workspace/TodoApp/src/contexts/TaskContext.tsx
import { Dispatch, ReactNode, SetStateAction, createContext } from "react";
import type { UUID } from "../types/user";

interface TaskState {
  selectedTaskId: UUID | null;
  anchorEl: null | HTMLElement;
  anchorPosition: { top: number; left: number } | null;
  expandedTasks: Set<UUID>;
  multipleSelectedTasks: UUID[];
  search: string;
  editModalOpen: boolean;
  deleteDialogOpen: boolean;
}

interface TaskActions {
  setSelectedTaskId: Dispatch<SetStateAction<UUID | null>>;
  setAnchorEl: Dispatch<SetStateAction<null | HTMLElement>>;
  setAnchorPosition: Dispatch<SetStateAction<{ top: number; left: number } | null>>;
  setExpandedTasks: Dispatch<SetStateAction<Set<UUID>>>;
  setMultipleSelectedTasks: Dispatch<SetStateAction<UUID[]>>;
  setSearch: Dispatch<SetStateAction<string>>;
  toggleShowMore: (taskId: UUID) => void;
  handleSelectTask: (taskId: UUID) => void;
  highlightMatchingText: (text: string) => ReactNode;
  setEditModalOpen: Dispatch<SetStateAction<boolean>>;
  setDeleteDialogOpen: Dispatch<SetStateAction<boolean>>;
  handleDeleteTask: () => void;
  handleCloseMoreMenu: () => void;
}

export type TaskContextType = TaskState & TaskActions;

export const TaskContext = createContext<TaskContextType>({} as TaskContextType);


// File: workspace/TodoApp/src/constants/defaultUser.ts
import { EmojiStyle } from "emoji-picker-react";
import type { User } from "../types/user";
import { systemInfo } from "../utils";

/**
 * Represents a default user object.
 */
export const defaultUser: User = {
  name: null,
  createdAt: new Date(),
  profilePicture: null,
  emojisStyle:
    systemInfo.os === "iOS" || systemInfo.os === "macOS" ? EmojiStyle.NATIVE : EmojiStyle.APPLE,
  tasks: [],
  theme: "system",
  darkmode: "auto",
  settings: [
    {
      enableCategories: true,
      doneToBottom: false,
      enableGlow: true,
      simpleEmojiPicker: false,
      enableReadAloud: "speechSynthesis" in window,
      voice: "Google UK English Male",
      appBadge: false,
      voiceVolume: 0.6,
    },
  ],
  categories: [
    { id: "857f0db6-43b2-43eb-8143-ec4e26472516", name: "Home", emoji: "1f3e0", color: "#1fff44" },
    { id: "0292cba5-f6e2-41c4-b5a7-c59a0aaecfe3", name: "Work", emoji: "1f3e2", color: "#248eff" },
    {
      id: "a47a4af1-d720-41eb-9121-d3728605a62b",
      name: "Personal",
      emoji: "1f464",
      color: "#e843fe",
    },
    {
      id: "393068a9-9db7-4dfa-a00f-cd359f8024e8",
      name: "Health/Fitness",
      emoji: "1f4aa",
      color: "#ffdf3d",
    },
    {
      id: "afa0fdb4-f668-4d5a-9ad0-4e22d2b8e841",
      name: "Education",
      emoji: "1f4da",
      color: "#ff8e24",
    },
  ],
  colorList: [
    "#FF69B4",
    "#FF22B4",
    "#C6A7FF",
    "#7ACCFA",
    "#4898F4",
    "#5061FF",
    "#3DFF7F",
    "#3AE836",
    "#FFEA28",
    "#F9BE26",
    "#FF9518",
    "#FF5018",
    "#FF2F2F",
  ],
};


// File: workspace/TodoApp/src/constants/constants.ts
/**
 * Maximum length allowed for task names.
 */
export const TASK_NAME_MAX_LENGTH = 40;

/**
 * Maximum length allowed for task descriptions.
 */
export const DESCRIPTION_MAX_LENGTH = 350;

/**
 * Shorter length for displaying descriptions with a "Show More" button.
 */
export const DESCRIPTION_SHORT_LENGTH = 100;

/**
 * Maximum length allowed for user names.
 */
export const USER_NAME_MAX_LENGTH = 14;

/**
 * Maximum length allowed for profile picture URLs.
 */
export const PROFILE_PICTURE_MAX_LENGTH = 255;

/**
 * Maximum length allowed for category names.
 */
export const CATEGORY_NAME_MAX_LENGTH = 20;

/**
 * Maximum number of categories can be assigned to one task
 */
export const MAX_CATEGORIES_IN_TASK = 3;

/**
 * Maximum number of colors in color picker list a user can have.
 */
export const MAX_COLORS_IN_LIST = 32;

/**
 * Maximum number of tasks a user can have.
 */
// export const MAX_TASKS: number = 200;

/**
 * Regular expression to match URLs in a string
 */
export const URL_REGEX = /((?:https?):\/\/[^\s/$.?#].[^\s]*)/gi;


// File: workspace/TodoApp/src/constants/index.ts
export * from "./constants";


// File: workspace/TodoApp/src/utils/saveQRCode.ts
/**
 *  Function to handle downloading QR code as PNG image
 */
export const saveQRCode = (taskName: string) => {
  taskName = taskName.length > 32 ? taskName.substring(0, 32) + "..." : taskName;
  const svgElement = document.getElementById("QRCodeShare") as SVGElement | null;
  if (!svgElement) {
    console.error("QR Code not found.");
    return;
  }

  const svgData = new XMLSerializer().serializeToString(svgElement);
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("Canvas context not supported.");
    return;
  }

  const img = new Image();
  img.onload = () => {
    const canvasWidth = img.width + 20;
    const canvasHeight = img.height + 70;

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    canvas.style.borderRadius = "10px";

    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    // Draw QR code
    const qrCodeX = (canvasWidth - img.width) / 2;
    const qrCodeY = 10;
    ctx.drawImage(img, qrCodeX, qrCodeY);
    // Draw task name
    ctx.font = "bold 20px Poppins";
    const textWidth = ctx.measureText(taskName).width;
    const centerX = (canvasWidth - textWidth) / 2;
    const bottomY = canvasHeight - 35;

    ctx.fillStyle = "black";
    ctx.fillText(taskName, centerX, bottomY);
    // Draw attribution text
    const text2 = "Todo App by github.com/maciekt07";
    ctx.font = "14px Poppins";
    const text2Width = ctx.measureText(text2).width;
    const text2X = (canvasWidth - text2Width) / 2;
    const text2Y = canvasHeight - 10;
    ctx.fillText(text2, text2X, text2Y);
    // Convert canvas to PNG data URL
    const pngFile = canvas.toDataURL("image/png");
    // Create download link
    const downloadLink = document.createElement("a");
    downloadLink.download = `QRCode${taskName ? " " + taskName : ""}.png`;
    downloadLink.href = pngFile;
    downloadLink.click();
  };
  // Load SVG data into image element
  img.src = `data:image/svg+xml;base64,${btoa(svgData)}`;
};


// File: workspace/TodoApp/src/utils/getSystemInfo.ts
type OperatingSystem = "Windows" | "macOS" | "Linux" | "iOS" | "Android" | "Unknown";
type Browser = "Chrome" | "Firefox" | "Safari" | "Edge" | "Unknown";

const userAgent = window.navigator.userAgent;

const getOperatingSystem = (): OperatingSystem => {
  if (/Windows NT/i.test(userAgent)) return "Windows";
  if (/iPhone|iPad|iPod/i.test(userAgent)) return "iOS";
  if (/Mac/i.test(userAgent)) return "macOS";
  if (/Linux/i.test(userAgent)) return "Linux";
  if (/Android/i.test(userAgent)) return "Android";
  return "Unknown";
};

const getBrowser = (): Browser => {
  if (/Chrome/i.test(userAgent) && !/Edge/i.test(userAgent)) return "Chrome";
  if (/Firefox/i.test(userAgent)) return "Firefox";
  if (/Safari/i.test(userAgent) && !/Chrome/i.test(userAgent)) return "Safari";
  if (/Edg/i.test(userAgent)) return "Edge";
  return "Unknown";
};

export const systemInfo = { os: getOperatingSystem(), browser: getBrowser() };


// File: workspace/TodoApp/src/utils/getRandomGreeting.ts
/**
 * Returns a random greeting message to inspire productivity.
 * @returns {string} A random greeting message with optional emoji code.
 */
export const getRandomGreeting = (): string => {
  const hoursLeft = 24 - new Date().getHours();

  const greetingsText: string[] = [
    "Let's make today count! **1f680**",
    "Get things done and conquer the day!",
    "Embrace the power of productivity!",
    "Set your goals, crush them, repeat.",
    "Today is a new opportunity to be productive!",
    "Make every moment count.",
    "Stay organized, stay ahead.",
    "Take charge of your day!",
    "One task at a time, you've got this!",
    "Productivity is the key to success. **1f511**",
    "Let's turn plans into accomplishments!",
    "Start small, achieve big.",
    "Be efficient, be productive.",
    "Harness the power of productivity!",
    "Get ready to make things happen!",
    "It's time to check off those tasks! **2705**",
    "Start your day with a plan! **1f5d3-fe0f**",
    "Stay focused, stay productive.",
    "Unlock your productivity potential. **1f513**",
    "Turn your to-do list into a to-done list! **1f4dd**",

    `Have a wonderful  ${new Date().toLocaleDateString("en", {
      weekday: "long",
    })}!`,
    `Happy ${new Date().toLocaleDateString("en", {
      month: "long",
    })}! A great month for productivity!`,
    hoursLeft > 4
      ? `${hoursLeft} hours left in the day. Use them wisely!`
      : `Only ${hoursLeft} hours left in the day`,
  ];

  const randomIndex = Math.floor(Math.random() * greetingsText.length);
  return greetingsText[randomIndex];
};


// File: workspace/TodoApp/src/utils/calculateTimeDiff.ts
import { timeAgo } from ".";

/**
 * Calculates the difference between a given date and the current date.
 * @param {Date} date - The target date to calculate the difference from.
 * @param {string} [lang=navigator.language || "en-US"] - The language code used for formatting.
 * @returns {string} A string representing the calculated difference in `Intl` format.
 */
export const calculateDateDifference = (
  date: Date,
  lang: string = navigator.language || "en-US"
): string => {
  const currentDate = new Date();
  const targetDate = new Date(date);
  const difference = targetDate.getTime() - currentDate.getTime();
  const differenceDays = Math.floor(difference / (1000 * 60 * 60 * 24));
  const differenceHours = Math.floor(difference / (1000 * 60 * 60));
  const differenceMinutes = Math.floor(difference / (1000 * 60));
  const userLocale = lang;

  if (targetDate < currentDate) {
    return `Not completed on time (${timeAgo(targetDate, userLocale)})`;
  } else if (targetDate.toDateString() === currentDate.toDateString()) {
    return new Intl.RelativeTimeFormat(userLocale, { numeric: "auto" }).format(
      differenceHours > 0 ? differenceHours : differenceMinutes,
      differenceHours > 0 ? "hour" : "minute"
    );
  } else if (targetDate.getDate() === currentDate.getDate() + 1) {
    return new Intl.RelativeTimeFormat(userLocale, { numeric: "auto" }).format(1, "day");
  } else if (differenceDays <= 7) {
    const dayOfWeek = new Intl.DateTimeFormat(userLocale, { weekday: "long" }).format(date);
    return `${dayOfWeek} (${new Intl.RelativeTimeFormat(userLocale, { numeric: "auto" }).format(
      differenceDays,
      "day"
    )})`;
  } else {
    return new Intl.RelativeTimeFormat(userLocale, { numeric: "auto" }).format(
      differenceDays,
      "day"
    );
  }
};


// File: workspace/TodoApp/src/utils/exportTasksToJson.ts
import type { Task } from "../types/user";

/**
 * Exports an array of tasks to a JSON file and initiates the download.
 * @param {Task[]} selectedTasks - The array of tasks to be exported.
 */
export const exportTasksToJson = (selectedTasks: Task[]): void => {
  // Get the current date and time for the filename
  const timestamp = new Date().toLocaleString().replace(/[/:, ]/g, "_");
  const filename = `Tasks_${timestamp}.json`;

  // Create a JSON blob
  const dataStr = JSON.stringify(selectedTasks, null, 2);
  const blob = new Blob([dataStr], { type: "application/json" });

  // Create a URL for the blob
  const url = window.URL.createObjectURL(blob);

  // Create a link element and initiate the download
  const linkElement = document.createElement("a");
  linkElement.href = url;
  linkElement.download = filename;
  linkElement.click();
  console.log(`Exported tasks to ${filename}`);
  // Clean up the URL object
  window.URL.revokeObjectURL(url);
};


// File: workspace/TodoApp/src/utils/timeAgo.ts
/**
 * Converts a given date to a human-readable relative time string.
 *
 * @param {Date} date - The date to be converted.
 * @returns {string} A string representing the relative time using `Intl` format (e.g., "2 days ago").
 */
export const timeAgo = (date: Date, lang = navigator.language || "en-US"): string => {
  // Get the current date and time
  const now = new Date();
  date = new Date(date);
  // Calculate the time difference in seconds
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  // Create an Intl.RelativeTimeFormat instance with the user's language
  const rtf = new Intl.RelativeTimeFormat(lang, { numeric: "auto" });

  // Determine the appropriate unit and format the result
  if (diffInSeconds < 60) {
    return rtf.format(-diffInSeconds, "second");
  } else if (diffInSeconds < 3600) {
    const minutes = Math.floor(diffInSeconds / 60);
    return rtf.format(-minutes, "minute");
  } else if (diffInSeconds < 86400) {
    const hours = Math.floor(diffInSeconds / 3600);
    return rtf.format(-hours, "hour");
  } else {
    const days = Math.floor(diffInSeconds / 86400);
    return rtf.format(-days, "day");
  }
};


// File: workspace/TodoApp/src/utils/formatDate.ts
export const formatDate = (date: Date): string => {
  const today = new Date();
  const yesterday = new Date(today);
  yesterday.setDate(today.getDate() - 1);
  const oneDay = 24 * 60 * 60 * 1000; // One day in milliseconds
  const oneWeek = 7 * oneDay; // One week in milliseconds

  const timeDifference = date.getTime() - today.getTime();

  const rtf = new Intl.RelativeTimeFormat(navigator.language, { numeric: "auto" });

  if (isSameDay(date, today)) {
    return rtf.format(0, "day") + ` ${formatTime(date)}`;
  } else if (isSameDay(date, yesterday)) {
    return rtf.format(-1, "day") + ` ${formatTime(date)}`;
  } else if (timeDifference > -oneWeek) {
    return `${getDayOfWeek(date)} ${formatTime(date)}`;
  } else {
    return formatDateOnly(date);
  }
};

const isSameDay = (date1: Date, date2: Date): boolean => {
  return (
    date1.getFullYear() === date2.getFullYear() &&
    date1.getMonth() === date2.getMonth() &&
    date1.getDate() === date2.getDate()
  );
};

const formatTime = (date: Date): string => {
  return date.toLocaleTimeString(navigator.language, {
    hour: "2-digit",
    minute: "2-digit",
  });
};

const formatDateOnly = (date: Date): string => {
  const options: Intl.DateTimeFormatOptions = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
  };
  return date.toLocaleDateString(navigator.language, options);
};

const getDayOfWeek = (date: Date): string =>
  date.toLocaleDateString(navigator.language, { weekday: "long" });


// File: workspace/TodoApp/src/utils/getTaskCompletionText.ts
/**
 * Returns a task completion message based on the completion percentage.
 * @param {number} completionPercentage - The completion percentage of tasks.
 * @returns {string} A task completion message.
 */
export const getTaskCompletionText = (completionPercentage: number): string => {
  switch (true) {
    case completionPercentage === 0:
      return "No tasks completed yet. Keep going!";
    case completionPercentage === 100:
      return "Congratulations! All tasks completed!";
    case completionPercentage >= 75:
      return "Almost there!";
    case completionPercentage >= 50:
      return "You're halfway there! Keep it up!";
    case completionPercentage >= 25:
      return "You're making good progress.";
    default:
      return "You're just getting started.";
  }
};


// File: workspace/TodoApp/src/utils/index.ts
export { calculateDateDifference } from "./calculateTimeDiff";
export { displayGreeting } from "./displayGreeting";
export { exportTasksToJson } from "./exportTasksToJson";
export { formatDate } from "./formatDate";
export { getFontColor } from "./getFontColor";
export { getRandomGreeting } from "./getRandomGreeting";
export { systemInfo } from "./getSystemInfo";
export { getTaskCompletionText } from "./getTaskCompletionText";
export { saveQRCode } from "./saveQRCode";
export { showToast } from "./showToast";
export { timeAgo } from "./timeAgo";


// File: workspace/TodoApp/src/utils/showToast.tsx
import styled from "@emotion/styled";
import { Button } from "@mui/material";
import { ReactNode } from "react";
import toast, { Toast, ToastOptions, ToastType } from "react-hot-toast";

interface ToastProps extends ToastOptions {
  disableClickDismiss?: boolean;
  disableVibrate?: boolean;
  dismissButton?: boolean;
  type?: ToastType;
}

/**
 * Function to display a toast notification.
 * @param message - The message to display in the toast notification.
 * @param type - The type of toast notification to display.
 * @param toastOptions - Additional options to configure the toast notification.
 * @returns {void}
 */

export const showToast = (
  message: string | ReactNode,
  {
    type,
    disableClickDismiss,
    disableVibrate,
    dismissButton,
    ...toastOptions
  }: ToastProps = {} as ToastProps
): void => {
  // Selects the appropriate toast function based on the specified type or defaults to success.
  const toastFunction = {
    error: toast.error,
    success: toast.success,
    loading: toast.loading,
    blank: toast,
    custom: toast.custom,
  }[type || "success"];

  // Vibrates the device based on the toast type, unless disabled or not supported.
  if (!disableVibrate && "vibrate" in navigator) {
    const vibrationPattern = type === "error" ? [100, 50, 100] : [100];
    try {
      navigator.vibrate(vibrationPattern);
    } catch (err) {
      console.log(err);
    }
  }

  // Display the toast notification.
  toastFunction(
    (t: Toast) => (
      <div onClick={!disableClickDismiss && !dismissButton ? () => toast.dismiss(t.id) : undefined}>
        {message}
        {dismissButton && (
          <div>
            <DismissButton onClick={() => toast.dismiss(t.id)}>Dismiss</DismissButton>
          </div>
        )}
      </div>
    ),
    {
      ...toastOptions, // Passes any additional toast options.
    }
  );

  const DismissButton = styled(Button)`
    width: 100%;
    padding: 12px 24px;
    border-radius: 16px;
    margin-top: 8px;
    font-size: 16px;
  `;
  DismissButton.defaultProps = {
    variant: "outlined",
  };
};


// File: workspace/TodoApp/src/utils/getFontColor.ts
import { ColorPalette } from "../theme/themeConfig";

/**
 * Returns the appropriate font color (either black or white) based on the provided background color in hex format.
 * @param {string} backgroundColor - The background color in hexformat (e.g., "#FFFFFF").
 * @returns {string} The font color in hex format.
 */
export const getFontColor = (backgroundColor: string): string => {
  const hexColor = backgroundColor.replace("#", "");
  const red = parseInt(hexColor.substr(0, 2), 16);
  const green = parseInt(hexColor.substr(2, 2), 16);
  const blue = parseInt(hexColor.substr(4, 2), 16);
  const brightness = (red * 299 + green * 587 + blue * 114) / 1000;
  return brightness > 125 ? ColorPalette.fontDark : ColorPalette.fontLight;
};


// File: workspace/TodoApp/src/utils/displayGreeting.ts
/**
 * Returns a greeting based on the current time.
 * @returns {string} The appropriate greeting.
 */
export const displayGreeting = (): string => {
  const currentTime = new Date();
  const currentHour = currentTime.getHours();
  let greeting: string;
  if (currentHour < 12 && currentHour >= 5) {
    greeting = "Good morning";
  } else if (currentHour < 18 && currentHour > 12) {
    greeting = "Good afternoon";
  } else {
    greeting = "Good evening";
  }

  return greeting;
};


// File: workspace/TodoApp/src/styles/categories.styled.tsx
import styled from "@emotion/styled";
import { getFontColor } from "../utils";
import { fadeIn } from "./keyframes.styled";
import { Button, TextField } from "@mui/material";

export const CategoriesContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  gap: 40px;
`;

export const CategoryElementsContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  max-height: 350px;
  background: ${({ theme }) => getFontColor(theme.secondary)}1a;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 24px 18px;
  border-radius: 18px 0 0 18px;
  /* Custom Scrollbar Styles */
  ::-webkit-scrollbar {
    width: 8px;
    border-radius: 4px;
    background-color: ${({ theme }) => getFontColor(theme.secondary) + "15"};
  }

  ::-webkit-scrollbar-thumb {
    background-color: ${({ theme }) => getFontColor(theme.secondary) + "30"};
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background-color: ${({ theme }) => getFontColor(theme.secondary) + "50"};
  }

  ::-webkit-scrollbar-track {
    border-radius: 4px;
    background-color: ${({ theme }) => getFontColor(theme.secondary) + "15"};
  }
`;

export const AddContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  gap: 4px;
`;

export const CategoryElement = styled.div<{ clr: string }>`
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 350px;
  margin: 6px 0;
  padding: 12px;
  border-radius: 18px;
  background: ${({ clr }) => clr};
  color: ${({ clr }) => getFontColor(clr)};
  animation: ${fadeIn} 0.5s ease-in-out;
`;

export const CategoryContent = styled.div`
  display: flex;
  align-items: center;
  font-weight: 500;
  margin: 0 4px;
  gap: 4px;
`;

export const ActionButton = styled.div`
  background: #ffffffcd;
  border-radius: 100%;
  margin: 0 4px;
`;
export const CategoryInput = styled(TextField)`
  margin: 12px;

  .MuiOutlinedInput-root {
    border-radius: 16px;
    width: 350px;
    color: ${({ theme }) => getFontColor(theme.secondary)};
  }
  & .MuiFormHelperText-root {
    color: ${({ theme }) => getFontColor(theme.secondary)};
    opacity: 0.8;
  }
`;

export const EditNameInput = styled(TextField)`
  margin-top: 8px;
  .MuiOutlinedInput-root {
    border-radius: 16px;
    width: 300px;
  }
`;

export const AddCategoryButton = styled(Button)`
  border: none;
  padding: 18px 48px;
  font-size: 24px;
  background: ${({ theme }) => theme.primary};
  color: ${({ theme }) => getFontColor(theme.primary)};
  border-radius: 999px;
  font-weight: bold;
  cursor: pointer;
  transition: 0.3s all;
  margin: 20px;
  width: 350px;
  text-transform: capitalize;
  &:hover {
    box-shadow: 0px 0px 24px 0px ${({ theme }) => theme.primary + "80"};
    background: ${({ theme }) => theme.primary};
  }
  &:disabled {
    box-shadow: none;
    cursor: not-allowed;
    opacity: 0.7;
    color: white;
  }
`;


// File: workspace/TodoApp/src/styles/taskManagement.styled.tsx
import styled from "@emotion/styled";
import { Box, Button } from "@mui/material";
import { getFontColor } from "../utils";
import { Info } from "@mui/icons-material";

//TODO: design this better
export const TaskManagementContainer = styled(Box)<{ backgroundClr: string; selected: boolean }>`
  display: flex;
  align-items: center;
  justify-content: left;
  margin: 8px;
  padding: 10px 4px;
  border-radius: 16px;
  background: ${({ theme }) => getFontColor(theme.secondary)}15;
  border: 2px solid ${({ backgroundClr }) => backgroundClr};
  box-shadow: ${({ selected, backgroundClr }) => selected && `0 0 8px 1px ${backgroundClr}`};
  transition: 0.3s all;
  width: 300px;
  cursor: "pointer";
  & span {
    font-weight: ${({ selected }) => (selected ? 600 : 500)}!important;
  }
`;

export const ManagementHeader = styled.h2`
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
`;

export const ListContent = styled.div`
  display: flex;
  justify-content: left;
  align-items: center;
  gap: 6px;
`;

export const DropZone = styled.div<{ isDragging: boolean }>`
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  gap: 6px;
  border: 2px dashed ${({ theme }) => theme.primary};
  border-radius: 16px;
  padding: 32px 64px;
  text-align: center;
  max-width: 300px;
  box-shadow: ${({ isDragging, theme }) => isDragging && `0 0 32px 0px ${theme.primary}`};
  transition: 0.3s all;
  & div {
    font-weight: 500;
  }
`;

export const InfoIcon = styled(Info)`
  color: ${({ theme }) => getFontColor(theme.secondary)};
`;

export const ManagementContainer = styled(Box)`
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 20px;
  max-height: 350px;
  overflow-y: auto;

  /* Custom Scrollbar Styles */
  ::-webkit-scrollbar {
    width: 8px;
    border-radius: 4px;
    background-color: ${({ theme }) => getFontColor(theme.secondary)}15;
  }

  ::-webkit-scrollbar-thumb {
    background-color: ${({ theme }) => getFontColor(theme.secondary)}30;
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background-color: ${({ theme }) => getFontColor(theme.secondary)}50;
  }

  ::-webkit-scrollbar-track {
    border-radius: 4px;
    background-color: ${({ theme }) => getFontColor(theme.secondary)}15;
  }
`;

export const ManagementButtonsContainer = styled(Box)`
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  gap: 24px;
`;

export const ManagementButton = styled(Button)`
  padding: 12px 18px;
  border-radius: 14px;
  width: 300px;

  &:disabled {
    color: ${({ theme }) => getFontColor(theme.secondary) + "82"};
    border-color: ${({ theme }) => getFontColor(theme.secondary) + "82"};
  }
`;
ManagementButton.defaultProps = {
  variant: "outlined",
};


// File: workspace/TodoApp/src/styles/home.styled.tsx
import styled from "@emotion/styled";
import { fadeIn, fadeInLeft, progressPulse, pulseAnimation } from "./keyframes.styled";
import { Box, Button, CircularProgress, css } from "@mui/material";
import { getFontColor } from "../utils";
import { ColorPalette } from "../theme/themeConfig";

export const GreetingHeader = styled.div`
  display: flex;
  margin-top: 12px;
  font-size: 26px;
  font-weight: bold;
  margin-top: 16px;
  margin-left: 8px;

  @media (max-width: 550px) {
    font-size: 22px;
  }
`;

export const GreetingText = styled.div`
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 16px;
  margin-top: 4px;
  margin-left: 8px;
  font-style: italic;
  animation: ${fadeInLeft} 0.5s ease-in-out;
`;

export const TasksCountContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
`;
//TODO: design this better for light themes
export const TasksCount = styled.div<{ glow: boolean }>`
  color: ${({ theme }) => getFontColor(theme.secondary)};
  /* background: #090b2258; */
  background: ${({ theme }) =>
    getFontColor(theme.secondary) === ColorPalette.fontLight ? "#090b2258" : "#ffffff3e"};
  transition: 0.3s all;
  display: flex;
  align-items: center;
  justify-content: left;
  gap: 8px 16px;
  padding: 20px 24px;
  margin: 24px 0 12px 0;
  border-radius: 24px;
  width: 650px;
  border: 1px solid
    ${({ theme }) =>
      getFontColor(theme.secondary) === ColorPalette.fontLight ? "#44479cb7" : theme.primary};
  @media (min-width: 1024px) {
    padding: 24px;
  }
`;

export const TaskCountTextContainer = styled.div`
  line-height: 1.7;
  margin-left: 6px;
`;

export const TaskCountHeader = styled.h4`
  margin: 0;
  font-size: 16px;
  @media (min-width: 1024px) {
    font-size: 17px;
  }
`;

export const TaskCompletionText = styled.p`
  margin: 0;
  font-size: 16px;
`;

export const ProgressPercentageContainer = styled(Box)<{ glow: boolean }>`
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  /* background: #090b2287; */
  background: ${({ theme }) =>
    getFontColor(theme.secondary) === ColorPalette.fontLight ? "#090b2287" : "#ffffff5c"};

  border-radius: 100px;
  margin: -5px;
  border: 1px solid
    ${({ theme }) =>
      getFontColor(theme.secondary) === ColorPalette.fontLight ? "#44479cb7" : theme.primary};
  box-shadow: ${({ theme }) =>
    `0 0 18px -2px ${
      getFontColor(theme.secondary) === ColorPalette.fontLight ? "#090b22" : "#bababa"
    }`};
  & .MuiTypography-root {
    color: ${({ theme }) => getFontColor(theme.secondary)};
  }
  animation: ${({ theme, glow }) =>
    glow
      ? css`
          ${progressPulse(theme.primary)} 4s infinite ease-in
        `
      : "none"};
`;

export const StyledProgress = styled(CircularProgress)<{ glow: boolean }>`
  z-index: 1;
  margin: 2px;
  filter: ${({ glow, theme }) => (glow ? `drop-shadow(0 0 6px ${theme.primary}c8)` : "none")};
  transition: 0.3s filter;
`;

export const AddButton = styled(Button)<{ animate?: boolean; glow: boolean }>`
  cursor: pointer;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  position: fixed;
  bottom: 24px;
  width: 72px;
  height: 72px;
  border-radius: 100%;
  background-color: ${({ theme }) => theme.primary};
  color: ${({ theme }) => getFontColor(theme.primary)};
  right: 16vw;
  box-shadow: ${({ glow, theme }) => (glow ? `0px 0px 32px -8px ${theme}` : "none")};
  transition: background-color 0.3s, backdrop-filter 0.3s, box-shadow 0.3s;

  &:hover {
    box-shadow: none;
    background-color: ${({ theme }) => theme.primary};
    backdrop-filter: blur(6px);
  }

  ${({ animate, theme }) =>
    animate &&
    css`
      animation: ${pulseAnimation(theme.primary, 14)} 1.2s infinite;
    `}

  @media (max-width: 1024px) {
    right: 24px;
  }
`;

export const Offline = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 6px;
  text-shadow: 0 0 8px #ffffff56;
  margin-top: 20px;
  opacity: 0.8;
  animation: ${fadeIn} 0.5s ease;
`;


// File: workspace/TodoApp/src/styles/addTask.styled.tsx
import styled from "@emotion/styled";
import { Button, TextField } from "@mui/material";
import { getFontColor } from "../utils";

export const Container = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
`;

export const AddTaskButton = styled(Button)`
  margin-top: 4px;
  border: none;
  padding: 16px 32px;
  font-size: 24px;
  background: ${({ theme }) => theme.primary};
  color: white;
  border-radius: 999px;
  font-weight: bold;
  cursor: pointer;
  transition: 0.3s all;
  margin: 20px;
  width: 400px;
  text-transform: capitalize;
  &:hover {
    box-shadow: 0px 0px 24px 0px ${({ theme }) => theme.primary + "80"};
    background: ${({ theme }) => theme.primary};
  }
  &:disabled {
    box-shadow: none;
    cursor: not-allowed;
    opacity: 0.7;
    color: ${({ theme }) => getFontColor(theme.secondary)};
  }
`;
export const StyledInput = styled(TextField)<{ helpercolor?: string }>`
  margin: 12px;
  & .MuiOutlinedInput-root {
    border-radius: 16px;
    transition: 0.3s all;
    width: 400px;
    color: ${({ theme }) => getFontColor(theme.secondary)};
  }
  .MuiFormHelperText-root {
    color: ${({ helpercolor, theme }) => helpercolor || getFontColor(theme.secondary)};
    opacity: 0.8;
  }
`;


// File: workspace/TodoApp/src/styles/keyframes.styled.tsx
import { keyframes } from "@emotion/react";

export const fadeInLeft = keyframes`
from {
  opacity: 0;
  transform: translateX(-40px)
}
to {
  opacity: 1;
  transform: translateX(0px)
  }
`;

export const fadeIn = keyframes`
from {
  opacity: 0;
}
`;

export const slideIn = keyframes`
  from{
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0);
  }
`;

export const slideInBottom = keyframes`
  from{
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
`;

export const scale = keyframes`
  from {
    transform: scale(0)
  }
  to {
    transform: scale(1)
  }
`;

export const pulseAnimation = (clr: string, shadowBlur: number = 12) => keyframes`
0% {
  transform: scale(0.95);
  box-shadow: 0 0 0 0 ${clr}b2;
}
70% {
  transform: scale(1);
  box-shadow: 0 0 0 ${shadowBlur}px ${clr}00;
}
100% {
  transform: scale(0.95);
  box-shadow: 0 0 0 0 ${clr}00;
}
`;

export const progressPulse = (clr: string) => keyframes`
  0% {
    filter: none;
  }
  50% {
    filter: drop-shadow(0 0 10px ${clr}78);
  }
  100% {
    filter: none;
  }
`;

export const ring = keyframes`
  0% { -webkit-transform: rotateZ(0); }
  1% { -webkit-transform: rotateZ(30deg); }
  3% { -webkit-transform: rotateZ(-28deg); }
  5% { -webkit-transform: rotateZ(34deg); }
  7% { -webkit-transform: rotateZ(-32deg); }
  9% { -webkit-transform: rotateZ(30deg); }
  11% { -webkit-transform: rotateZ(-28deg); }
  13% { -webkit-transform: rotateZ(26deg); }
  15% { -webkit-transform: rotateZ(-24deg); }
  17% { -webkit-transform: rotateZ(22deg); }
  19% { -webkit-transform: rotateZ(-20deg); }
  21% { -webkit-transform: rotateZ(18deg); }
  23% { -webkit-transform: rotateZ(-16deg); }
  25% { -webkit-transform: rotateZ(14deg); }
  27% { -webkit-transform: rotateZ(-12deg); }
  29% { -webkit-transform: rotateZ(10deg); }
  31% { -webkit-transform: rotateZ(-8deg); }
  33% { -webkit-transform: rotateZ(6deg); }
  35% { -webkit-transform: rotateZ(-4deg); }
  37% { -webkit-transform: rotateZ(2deg); }
  39% { -webkit-transform: rotateZ(-1deg); }
  41% { -webkit-transform: rotateZ(1deg); }
  43% { -webkit-transform: rotateZ(0); }
  100% { -webkit-transform: rotateZ(0); }
`;


// File: workspace/TodoApp/src/styles/globalStyles.tsx
import { Global, css, useTheme } from "@emotion/react";
import { getFontColor } from "../utils";
import { ColorPalette } from "../theme/themeConfig";

export const GlobalStyles = () => {
  const theme = useTheme();

  return (
    <Global
      styles={css`
        * {
          font-family: "Poppins", sans-serif !important;
          -webkit-tap-highlight-color: transparent;
          &::selection {
            background-color: ${theme.primary + "e1"};
            color: ${getFontColor(theme.primary)};
            text-shadow: 0 0 12px ${getFontColor(theme.primary) + "b9"};
          }
        }
        :root {
          font-family: "Poppins", sans-serif;
          line-height: 1.5;
          font-weight: 400;
          color-scheme: ${theme.darkmode ? "dark" : "light"};
          color: ${getFontColor(theme.secondary)};
          font-synthesis: none;
          text-rendering: optimizeLegibility;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
          -webkit-text-size-adjust: 100%;
          --rsbs-backdrop-bg: rgba(0, 0, 0, 0.3);
          --rsbs-bg: ${theme.darkmode ? "#383838" : "#ffffff"};
        }
        img {
          -webkit-user-select: none;
          -khtml-user-select: none;
          -moz-user-select: none;
          -o-user-select: none;
          user-select: none;
        }

        a {
          text-decoration: none;
          -webkit-text-decoration: none;
          color: inherit;
        }

        input[type="file"]::-webkit-file-upload-button {
          display: none;
        }
        div[role="dialog"] {
          border-radius: 42px 42px 0 0;
          z-index: 9999999;
        }

        div[data-rsbs-backdrop] {
          z-index: 999;
        }

        div[data-rsbs-header] {
          z-index: 999999;
          &::before {
            width: 60px;
            height: 6px;
            border-radius: 100px;
            background: #cfcfcf;
            margin-top: 2px;
          }
        }
        div[data-rsbs-header] {
          /* box-shadow: none;
          border-bottom-width: thin;
          border-bottom: 1px solid
            ${theme.darkmode ? "rgba(255, 255, 255, 0.12)" : "rgba(0, 0, 0, 0.12) "}; */
        }
        body {
          margin: 8px 16vw;
          touch-action: manipulation;
          //FIXME:
          background: ${theme.secondary};
          background-attachment: fixed;
          background-size: cover;
          transition: 0.3s background;
          @media (max-width: 1024px) {
            margin: 20px;
          }

          /* Custom Scrollbar Styles */
          ::-webkit-scrollbar {
            width: 8px;

            background-color: ${theme.secondary};
          }

          ::-webkit-scrollbar-thumb {
            background-color: ${theme.primary};
            border-radius: 64px;
          }

          ::-webkit-scrollbar-thumb:hover {
            background-color: ${theme.primary + "d8"};
          }

          ::-webkit-scrollbar-track {
            border-radius: 64px;
            background-color: ${theme.secondary};
          }
        }

        pre {
          background-color: #000000d7;
          color: white;
          padding: 16px;
          border-radius: 18px;
          overflow-x: auto;
        }

        .EmojiPickerReact {
          --epr-hover-bg-color: ${theme.primary + "af"};
          --epr-focus-bg-color: ${theme.primary + "af"};
          --epr-highlight-color: ${theme.primary};
          --epr-search-border-color: ${theme.primary};
          --epr-hover-bg-color: "red";
          border-radius: 20px !important;
          padding: 8px !important;
        }

        .epr-reactions {
          background: ${getFontColor(theme.secondary) === ColorPalette.fontDark
            ? ColorPalette.fontLight
            : ColorPalette.fontDark} !important;
        }

        .epr-emoji-category-label {
          backdrop-filter: blur(3px);
          -webkit-backdrop-filter: blur(3px);
        }
        .epr-emoji-native {
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
        }

        .epr-body,
        .MuiDialogContent-root,
        .MuiDrawer-paper,
        textarea {
          ::-webkit-scrollbar {
            width: 8px;
            border-radius: 4px;
            background-color: #84848415;
          }

          ::-webkit-scrollbar-thumb {
            background-color: #8484844b;
            border-radius: 4px;
          }

          ::-webkit-scrollbar-thumb:hover {
            background-color: #84848476;
          }

          ::-webkit-scrollbar-track {
            border-radius: 4px;
            background-color: #84848415;
          }
        }

        .MuiDialog-container {
          backdrop-filter: blur(4px);
        }
        .MuiPaper-elevation8 {
          border-radius: 16px !important;
        }
        .MuiSelect-select,
        .MuiSelect-select {
          display: flex !important;
          justify-content: left;
          align-items: center;
          gap: 4px;
        }
        .MuiTooltip-tooltip {
          color: ${theme.darkmode ? "white" : "black"} !important;
          background-color: ${theme.darkmode ? "#141431dd" : "#ededf3dd"} !important;
          backdrop-filter: blur(6px) !important;
          padding: 8px 16px !important;
          border-radius: 8px !important;
          font-size: 12px !important;
        }
        .MuiBottomNavigationAction-root {
          padding: 12px !important;
          margin: 0 !important;
          max-height: none;
        }
        .MuiSlider-valueLabel {
          border-radius: 10px !important;
          padding: 6px 14px !important;
          color: ${theme.darkmode ? "white" : "black"} !important;
          background-color: ${theme.darkmode ? "#141431dd" : "#ededf3dd"} !important;
          &::before,
          &::after {
            display: none;
          }
        }
        .MuiCircularProgress-circle {
          stroke-linecap: round !important;
        }
        .MuiTabs-indicator {
          border-radius: 24px !important;
          height: 3px !important;
        }
        .MuiAccordion-root {
          &::before {
            display: none;
          }
        }
      `}
    />
  );
};


// File: workspace/TodoApp/src/styles/index.ts
export * from "./globalStyles";
export * from "./home.styled";
export * from "./addTask.styled";
export * from "./keyframes.styled";
export * from "./common.styled";
export * from "./categories.styled";
export * from "./taskManagement.styled";


// File: workspace/TodoApp/src/styles/common.styled.tsx
import styled from "@emotion/styled";
import { Avatar, Button } from "@mui/material";
import { getFontColor } from "../utils";
import { CSSProperties } from "react";

export const DialogBtn = styled(Button)`
  padding: 10px 16px;
  border-radius: 16px;
  font-size: 16px;
  margin: 8px;
`;
export const StyledLink = styled.a<{ clr?: string }>`
  cursor: pointer;
  color: ${({ clr, theme }) => clr || theme.primary};
  display: inline-block;
  position: relative;
  text-decoration: none;
  font-weight: 500;
  transition: 0.3s all;
  &::after {
    content: "";
    position: absolute;
    width: 100%;
    transform: scaleX(0);
    height: 2px;
    bottom: 0;
    left: 0;
    background-color: ${({ clr, theme }) => clr || theme.primary};
    transform-origin: bottom right;
    transition: transform 0.25s ease-out;
    border-radius: 100px;
  }
  &:hover::after,
  &:focus-visible::after {
    transform: scaleX(1);
    transform-origin: bottom left;
  }
  &:hover {
    text-shadow: 0px 0px 20px ${({ clr, theme }) => clr || theme.primary};
  }
  &:focus,
  &:focus-visible {
    outline: none;
    box-shadow: none;
  }
`;
// linear-gradient(#A4AAB7, #868B95)
export const UserAvatar = styled(Avatar)<{ hasImage: boolean; size: CSSProperties["height"] }>`
  color: #ffffff;
  background: ${({ hasImage, theme }) =>
    hasImage ? "#ffffff1c" : theme.darkmode ? "#5e5e65" : "#8c919c"} !important;
  transition: 0.3s background;
  font-weight: 500;
  width: ${({ size }) => size};
  height: ${({ size }) => size};
  font-size: ${({ size }) => `calc(${size} / 2)`};
`;

UserAvatar.defaultProps = {
  translate: "no",
  slotProps: { img: { loading: "lazy" } },
};

// Styled button for color selection
export const ColorElement = styled.button<{ clr: string; secondClr?: string; size?: string }>`
  background: ${({ clr, secondClr }) =>
    secondClr ? `linear-gradient(135deg, ${clr} 50%, ${secondClr} 50%)` : clr};

  color: ${({ clr }) => getFontColor(clr || "")};
  border: none;
  cursor: pointer;
  width: ${({ size }) => size || "48px"};
  height: ${({ size }) => size || "48px"};
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  border-radius: 100%;
  transition: 0.2s all, 0s border;
  transform: scale(1);

  &:focus-visible {
    outline: 4px solid ${({ theme }) => theme.primary};
  }
  &:hover {
    /* transform: scale(1.05); */
    box-shadow: 0 0 12px ${({ clr }) => clr};
    /* outline: none; */
  }
`;

export const PathName = styled.code`
  background: #000000c8;
  color: white;
  font-family: consolas !important;
  padding: 4px 6px;
  border-radius: 8px;
`;


// File: workspace/TodoApp/src/components/Settings.tsx
import { useTheme } from "@emotion/react";
import styled from "@emotion/styled";
import {
  BrightnessAutoRounded,
  CachedRounded,
  DarkModeRounded,
  DeleteRounded,
  ExpandMoreRounded,
  Google,
  LightModeRounded,
  Microsoft,
  PersonalVideoRounded,
  VolumeDown,
  VolumeOff,
  VolumeUp,
  WifiOffRounded,
} from "@mui/icons-material";
import {
  Box,
  Button,
  Chip,
  Dialog,
  DialogActions,
  DialogTitle,
  FormControl,
  FormControlLabel,
  FormGroup,
  FormLabel,
  IconButton,
  MenuItem,
  Select,
  SelectChangeEvent,
  Slider,
  Stack,
  Switch,
  Tooltip,
} from "@mui/material";
import { Emoji, EmojiStyle } from "emoji-picker-react";
import { useContext, useEffect, useState } from "react";
import { defaultUser } from "../constants/defaultUser";
import { UserContext } from "../contexts/UserContext";
import { useOnlineStatus } from "../hooks/useOnlineStatus";
import { useSystemTheme } from "../hooks/useSystemTheme";
import { DialogBtn } from "../styles";
import type { AppSettings, DarkModeOptions } from "../types/user";
import { getFontColor, showToast, systemInfo } from "../utils";
import { ColorPalette } from "../theme/themeConfig";

interface SettingsProps {
  open: boolean;
  onClose: () => void;
}

//TODO: Redesign settings component to have tabs on the left side

export const SettingsDialog: React.FC<SettingsProps> = ({ open, onClose }) => {
  const { user, setUser } = useContext(UserContext);
  const { settings, emojisStyle, darkmode } = user;
  const [userSettings, setUserSettings] = useState<AppSettings>(settings[0]);
  const [lastStyle] = useState<EmojiStyle>(emojisStyle);

  const [availableVoices, setAvailableVoices] = useState<SpeechSynthesisVoice[]>([]);
  const [voiceVolume, setVoiceVolume] = useState<number>(settings[0].voiceVolume);
  const [prevVoiceVol, setPrevVoiceVol] = useState<number>(settings[0].voiceVolume);
  const [showLocalVoices, setShowLocalVoices] = useState<boolean>(false);

  const [storageUsage, setStorageUsage] = useState<number | undefined>(undefined);

  const isOnline = useOnlineStatus();
  const systemTheme = useSystemTheme();
  const theme = useTheme();

  // Array of available emoji styles with their labels
  const emojiStyles: { label: string; style: EmojiStyle }[] = [
    { label: "Apple", style: EmojiStyle.APPLE },
    { label: "Facebook, Messenger", style: EmojiStyle.FACEBOOK },
    { label: "Twitter, Discord", style: EmojiStyle.TWITTER },
    { label: "Google", style: EmojiStyle.GOOGLE },
    { label: "Native", style: EmojiStyle.NATIVE },
  ];

  // Array of available dark mode options
  const darkModeOptions: {
    label: string;
    mode: DarkModeOptions;
    icon: JSX.Element;
  }[] = [
    {
      label: "Auto",
      mode: "auto",
      icon: <BrightnessAutoRounded />,
    },
    {
      label: "System",
      mode: "system",
      icon: <PersonalVideoRounded />,
    },
    {
      label: "Light",
      mode: "light",
      icon: <LightModeRounded />,
    },
    {
      label: "Dark",
      mode: "dark",
      icon: <DarkModeRounded />,
    },
  ];

  // function to get the flag emoji for a given country code
  const getFlagEmoji = (countryCode: string): string =>
    typeof countryCode === "string"
      ? String.fromCodePoint(
          ...[...countryCode.toUpperCase()].map((x) => 0x1f1a5 + x.charCodeAt(0))
        )
      : "";

  // Function to get the available speech synthesis voices
  // https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis
  const getAvailableVoices = (): SpeechSynthesisVoice[] => {
    const voices = window.speechSynthesis.getVoices();
    const voiceInfoArray: SpeechSynthesisVoice[] = [];
    for (const voice of voices) {
      voiceInfoArray.push(voice);
    }
    return voiceInfoArray;
  };

  useEffect(() => {
    const availableVoices = getAvailableVoices();
    setAvailableVoices(availableVoices ?? []);

    const getStorageUsage = async () => {
      const storageUsage = await navigator.storage.estimate();
      setStorageUsage(storageUsage.usage);
    };
    getStorageUsage();
  }, []);

  // Ensure the voices are loaded before calling getAvailableVoices
  window.speechSynthesis.onvoiceschanged = () => {
    const availableVoices = getAvailableVoices();
    setAvailableVoices(availableVoices ?? []);
  };

  // Handler for updating individual setting options
  const handleSettingChange =
    (name: keyof AppSettings) => (event: React.ChangeEvent<HTMLInputElement>) => {
      const isChecked = event.target.checked;
      // cancel read aloud
      if (name === "enableReadAloud") {
        window.speechSynthesis.cancel();
      }
      if (name === "appBadge" && navigator.clearAppBadge && !isChecked) {
        navigator.clearAppBadge();
      }
      const updatedSettings: AppSettings = {
        ...userSettings,
        [name]: isChecked,
      };
      setUserSettings(updatedSettings);
      setUser((prevUser) => ({
        ...prevUser,
        settings: [updatedSettings],
      }));
    };

  // Handler for updating the selected emoji style
  const handleEmojiStyleChange = (event: SelectChangeEvent<unknown>) => {
    const selectedEmojiStyle = event.target.value as EmojiStyle;
    setUser((prevUser) => ({
      ...prevUser,
      emojisStyle: selectedEmojiStyle,
    }));
  };

  const handleDarkModeChange = (event: SelectChangeEvent<unknown>) => {
    const selectedDarkMode = event.target.value as DarkModeOptions;
    setUser((prevUser) => ({
      ...prevUser,
      darkmode: selectedDarkMode,
    }));
  };

  const handleVoiceChange = (event: SelectChangeEvent<unknown>) => {
    // Handle the selected voice
    const selectedVoice = availableVoices.find(
      (voice) => voice.name === (event.target.value as string)
    );
    if (selectedVoice) {
      // Update the user settings with the selected voice
      setUser((prevUser) => ({
        ...prevUser,
        settings: [
          {
            ...prevUser.settings[0],
            voice: selectedVoice.name,
          },
        ],
      }));
    }
  };

  // Function to handle changes in voice volume after mouse up
  const handleVoiceVolCommitChange = (
    _event: Event | React.SyntheticEvent<Element, Event>,
    value: number | number[]
  ) => {
    // Update user settings with the new voice volume
    setUser((prevUser) => ({
      ...prevUser,
      settings: [
        {
          ...prevUser.settings[0],
          voiceVolume: value as number,
        },
      ],
    }));
  };

  // Function to handle mute/unmute button click
  const handleMuteClick = () => {
    // Retrieve the current voice volume from user settings
    const vol = voiceVolume;
    // Save the previous voice volume before muting
    setPrevVoiceVol(vol);
    const newVoiceVolume =
      vol === 0 ? (prevVoiceVol !== 0 ? prevVoiceVol : defaultUser.settings[0].voiceVolume) : 0;
    setUser((prevUser) => ({
      ...prevUser,
      settings: [
        {
          ...prevUser.settings[0],
          voiceVolume: newVoiceVolume,
        },
      ],
    }));
    setVoiceVolume(newVoiceVolume);
  };

  const getLanguageRegion = (lang: string) => {
    if (!lang) {
      // If lang is undefined or falsy, return an empty string
      return "";
    }
    const langParts = lang.split("-");
    if (langParts.length > 1) {
      try {
        return new Intl.DisplayNames([lang], { type: "region" }).of(langParts[1]);
      } catch (error) {
        console.error("Error:", error);
        // Return the language itself if there's an error
        return lang;
      }
    } else {
      // If region is not specified, return the language itself
      return lang;
    }
  };

  const filteredVoices = showLocalVoices
    ? availableVoices.filter((voice) => voice.lang.startsWith(navigator.language))
    : availableVoices;

  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle sx={{ fontWeight: 600 }}>Settings</DialogTitle>
      <Container>
        <FormGroup>
          <FormControl>
            <FormLabel>Dark Mode</FormLabel>
            <StyledSelect
              value={darkmode}
              onChange={handleDarkModeChange}
              IconComponent={ExpandMoreRounded}
            >
              {darkModeOptions.map((option) => (
                <StyledMenuItem key={option.mode} value={option.mode}>
                  {option.icon} {option.label}
                  {option.mode === "system" && ` (${systemTheme})`}
                  {option.mode === "auto" &&
                    ` (${
                      getFontColor(theme.secondary) === ColorPalette.fontDark ? "light" : "dark"
                    })`}
                </StyledMenuItem>
              ))}
            </StyledSelect>
          </FormControl>
        </FormGroup>
        {/* Select component to choose the emoji style */}
        <FormGroup>
          <FormControl>
            <FormLabel>Emoji Settings</FormLabel>
            <StyledSelect
              value={emojisStyle}
              onChange={handleEmojiStyleChange}
              translate="no"
              IconComponent={ExpandMoreRounded}
            >
              {/* Show a disabled menu item when offline, indicating that the style can't be changed */}
              {!isOnline && (
                <MenuItem
                  disabled
                  style={{
                    opacity: 0.8,
                    display: "flex",
                    gap: "6px",
                    fontWeight: 500,
                  }}
                >
                  <WifiOffRounded /> You can't change the emoji style <br /> when you are offline.
                </MenuItem>
              )}

              {emojiStyles.map((style) => (
                <StyledMenuItem
                  key={style.style}
                  value={style.style}
                  translate="no"
                  disabled={
                    !isOnline &&
                    style.style !== EmojiStyle.NATIVE &&
                    style.style !== defaultUser.emojisStyle &&
                    style.style !== lastStyle
                  }
                >
                  <Emoji size={24} unified="1f60e" emojiStyle={style.style} />
                  &nbsp;
                  {/* Space For Native Emoji */}
                  {style.style === EmojiStyle.NATIVE && "\u00A0"}
                  {style.label}
                </StyledMenuItem>
              ))}
            </StyledSelect>

            <Tooltip title="Emoji picker will only show frequently used emojis">
              <FormGroup>
                <StyledFormLabel
                  sx={{ opacity: userSettings.simpleEmojiPicker ? 1 : 0.8 }}
                  control={
                    <Switch
                      checked={userSettings.simpleEmojiPicker}
                      onChange={handleSettingChange("simpleEmojiPicker")}
                    />
                  }
                  label="Simple Emoji Picker"
                />
              </FormGroup>
            </Tooltip>
          </FormControl>
          <Tooltip title="This will delete data about frequently used emojis">
            <Button
              color="error"
              variant="outlined"
              sx={{ my: "12px", p: "12px", borderRadius: "18px" }}
              onClick={() => {
                localStorage.removeItem("epr_suggested");
                showToast("Deleted emoji data.");
              }}
            >
              <DeleteRounded /> &nbsp; Clear Emoji Data
            </Button>
          </Tooltip>
        </FormGroup>

        {/* Switch components to control different app settings */}
        <FormGroup>
          <FormLabel>App Settings</FormLabel>
          <StyledFormLabel
            sx={{ opacity: userSettings.enableCategories ? 1 : 0.8 }}
            control={
              <Switch
                checked={userSettings.enableCategories}
                onChange={handleSettingChange("enableCategories")}
              />
            }
            label="Enable Categories"
          />
        </FormGroup>
        <FormGroup>
          <StyledFormLabel
            sx={{ opacity: userSettings.enableGlow ? 1 : 0.8 }}
            control={
              <Switch
                checked={userSettings.enableGlow}
                onChange={handleSettingChange("enableGlow")}
              />
            }
            label="Enable Glow Effect"
          />
        </FormGroup>
        <FormGroup>
          <StyledFormLabel
            sx={{ opacity: userSettings.enableReadAloud ? 1 : 0.8 }}
            control={
              <Switch
                checked={"speechSynthesis" in window && userSettings.enableReadAloud ? true : false}
                onChange={handleSettingChange("enableReadAloud")}
                disabled={"speechSynthesis" in window ? false : true}
              />
            }
            label="Enable Read Aloud"
          />
        </FormGroup>

        {"clearAppBadge" in navigator &&
          window.matchMedia("(display-mode: standalone)").matches && (
            <Tooltip
              title={
                "setAppBadge" in navigator
                  ? "This will show number of not done tasks in app icon if PWA is installed."
                  : "App Badge is not supported"
              }
            >
              <FormGroup>
                <StyledFormLabel
                  sx={{ opacity: userSettings.appBadge ? 1 : 0.8 }}
                  control={
                    <Switch
                      checked={"setAppBadge" in navigator && userSettings.appBadge ? true : false}
                      onChange={handleSettingChange("appBadge")}
                      disabled={"setAppBadge" in navigator ? false : true}
                    />
                  }
                  label="Enable App Badge"
                />
              </FormGroup>
            </Tooltip>
          )}
        <FormGroup>
          <StyledFormLabel
            sx={{ opacity: userSettings.doneToBottom ? 1 : 0.8 }}
            control={
              <Switch
                checked={userSettings.doneToBottom}
                onChange={handleSettingChange("doneToBottom")}
              />
            }
            label="Move Done Tasks To Bottom"
          />
        </FormGroup>

        {settings[0].enableReadAloud && (
          <FormGroup>
            <FormControl>
              <FormLabel>Voice Settings</FormLabel>
              <StyledFormLabel
                sx={{ opacity: showLocalVoices ? 1 : 0.8, maxWidth: "300px" }}
                control={
                  <Switch
                    checked={showLocalVoices}
                    onChange={() => setShowLocalVoices((prev) => !prev)}
                  />
                }
                label={`Local language voices only (${
                  getLanguageRegion(navigator.language) || "?"
                })`}
              />
              {filteredVoices.length !== 0 ? (
                <StyledSelect
                  value={settings[0].voice}
                  variant="outlined"
                  onChange={handleVoiceChange}
                  translate="no"
                  IconComponent={ExpandMoreRounded}
                  MenuProps={{
                    PaperProps: {
                      style: {
                        maxHeight: 500,
                        padding: "2px 6px",
                      },
                    },
                  }}
                >
                  {filteredVoices.map((voice) => (
                    <MenuItem
                      key={voice.name}
                      value={voice.name}
                      translate="no"
                      sx={{
                        padding: "10px",
                        borderRadius: "8px",
                      }}
                    >
                      {voice.name.startsWith("Google") && <Google />}
                      {voice.name.startsWith("Microsoft") && <Microsoft />} &nbsp;{" "}
                      {/* Remove Google or Microsoft at the beginning and anything within parentheses */}
                      {voice.name.replace(/^(Google|Microsoft)\s*|\([^()]*\)/gi, "")} &nbsp;
                      {/* windows does not display flag emotes correctly */}
                      {!/Windows NT 10/.test(navigator.userAgent) ? (
                        <Chip
                          sx={{ fontWeight: 500, padding: "4px" }}
                          label={getLanguageRegion(voice.lang || "")}
                          icon={
                            <span style={{ fontSize: "16px" }}>
                              {getFlagEmoji(voice.lang.split("-")[1] || "")}
                            </span>
                          }
                        />
                      ) : (
                        <span style={{ fontWeight: 500 }}>
                          {getLanguageRegion(voice.lang || "")}
                        </span>
                      )}
                      {voice.default && systemInfo.os !== "iOS" && systemInfo.os !== "macOS" && (
                        <span style={{ fontWeight: 600 }}>&nbsp;Default</span>
                      )}
                    </MenuItem>
                  ))}
                </StyledSelect>
              ) : (
                <NoVoiceStyles>
                  There are no voice styles available.
                  <Tooltip title="Refetch voices">
                    <IconButton
                      size="large"
                      onClick={() => {
                        setAvailableVoices(getAvailableVoices() ?? []);
                      }}
                    >
                      <CachedRounded fontSize="large" />
                    </IconButton>
                  </Tooltip>
                </NoVoiceStyles>
              )}
            </FormControl>

            <Box>
              <div style={{ display: "flex", justifyContent: "center", alignItems: "center" }}>
                <VolumeSlider spacing={2} direction="row" alignItems="center">
                  <Tooltip title={voiceVolume ? "Mute" : "Unmute"} onClick={handleMuteClick}>
                    <IconButton>
                      {voiceVolume === 0 ? (
                        <VolumeOff />
                      ) : voiceVolume <= 0.4 ? (
                        <VolumeDown />
                      ) : (
                        <VolumeUp />
                      )}
                    </IconButton>
                  </Tooltip>
                  <Slider
                    sx={{
                      width: "100%",
                    }}
                    value={voiceVolume}
                    onChange={(_event, value) => setVoiceVolume(value as number)}
                    onChangeCommitted={handleVoiceVolCommitChange}
                    min={0}
                    max={1}
                    step={0.01}
                    aria-label="Volume Slider"
                    valueLabelFormat={() => {
                      const vol = Math.floor(voiceVolume * 100);
                      return vol === 0 ? "Muted" : vol + "%";
                    }}
                    valueLabelDisplay="auto"
                  />
                </VolumeSlider>
              </div>
            </Box>
          </FormGroup>
        )}
        {storageUsage !== undefined && storageUsage !== 0 && (
          <FormGroup>
            <FormLabel>Storage Usage</FormLabel>
            <div>{storageUsage ? `${(storageUsage / 1024 / 1024).toFixed(2)} MB` : "0 MB"}</div>
          </FormGroup>
        )}
      </Container>
      <DialogActions>
        <DialogBtn onClick={onClose}>Close</DialogBtn>
      </DialogActions>
    </Dialog>
  );
};

const Container = styled.div`
  display: flex;
  justify-content: left;
  align-items: left;
  flex-direction: column;
  user-select: none;
  margin: 0 18px;
  gap: 6px;
`;

const StyledSelect = styled(Select)`
  width: 360px;
  margin: 8px 0;
`;

const StyledMenuItem = styled(MenuItem)`
  padding: 12px 20px;
  border-radius: 12px;
  margin: 0 8px;
  display: flex;
  gap: 6px;
`;

const StyledFormLabel = styled(FormControlLabel)`
  max-width: 350px;
`;

const NoVoiceStyles = styled.p`
  display: flex;
  align-items: center;
  flex-direction: column;
  gap: 6px;
  opacity: 0.8;
  font-weight: 500;
  max-width: 330px;
`;

const VolumeSlider = styled(Stack)`
  margin: 8px 0;
  background: #afafaf39;
  padding: 12px 24px 12px 18px;
  border-radius: 18px;
  transition: 0.3s all;
  width: 100%;
`;


// File: workspace/TodoApp/src/components/TaskIcon.tsx
import { useTheme } from "@emotion/react";
import { useContext } from "react";
import { UserContext } from "../contexts/UserContext";
import { getFontColor } from "../utils";

interface NotFoundIconProps {
  scale?: number;
  color?: string;
  variant?: "error" | "add" | "success";
}
/**
 * Component for displaying a svg task icon in theme color.
 */
export const TaskIcon = ({ scale = 1, color, variant = "error" }: NotFoundIconProps) => {
  const theme = useTheme();
  const { user } = useContext(UserContext);
  const { settings } = user;

  const taskIconClr = color || theme.primary;
  const secondIconClr = getFontColor(color || theme.primary);

  const renderIcon = () => {
    if (variant === "add") {
      return AddIcon;
    } else if (variant === "error") {
      return ErrorIcon;
    } else if (variant === "success") {
      return SuccessIcon;
    } else {
      return null;
    }
  };
  const AddIcon = (
    <>
      <rect
        x="124.093"
        y="286.465"
        width="87.6744"
        height="13.4884"
        rx="6.74419"
        transform="rotate(-90 124.093 286.465)"
        fill={secondIconClr}
      />
      <rect x="87" y="235.884" width="87.6744" height="13.4884" rx="6.74419" fill={secondIconClr} />
    </>
  );

  const ErrorIcon = (
    <>
      <rect
        x="95.0707"
        y="268.856"
        width="87.6744"
        height="13.4884"
        rx="6.74419"
        transform="rotate(-45 95.0707 268.856)"
        fill={secondIconClr}
      />

      <rect
        x="104.608"
        y="206.861"
        width="87.6744"
        height="13.4884"
        rx="6.74419"
        transform="rotate(45 104.608 206.861)"
        fill={secondIconClr}
      />
    </>
  );

  const SuccessIcon = (
    <path
      d="M96 242.159L119.159 265.318L165.476 219"
      stroke={secondIconClr}
      stroke-width="15"
      stroke-linecap="round"
      stroke-linejoin="round"
    />
  );

  return (
    <svg
      width={216 * scale}
      height={434 * scale}
      viewBox="0 0 261 434"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      style={{
        filter: settings[0].enableGlow
          ? `drop-shadow(0px 0px ${64 * scale}px ${taskIconClr}c8)`
          : "none",
      }}
    >
      <circle cx="130.837" cy="34.2327" r="26.7209" stroke={taskIconClr} stroke-width="14" />
      <rect
        y="51.7676"
        width="261"
        height="381.721"
        rx="45"
        fill={taskIconClr}
        fill-opacity="0.6"
      />
      <rect
        x="26.9767"
        y="80.0928"
        width="207.047"
        height="325.07"
        rx="35"
        fill="white"
        fill-opacity="0.9"
      />
      <rect
        x="64.7442"
        y="176.535"
        width="132.186"
        height="132.186"
        rx="66.093"
        fill={taskIconClr}
      />
      {renderIcon()}
      <rect x="77.5581" y="36.9307" width="106.558" height="56.6512" rx="18" fill={taskIconClr} />
    </svg>
  );
};


// File: workspace/TodoApp/src/components/TopBar.tsx
import styled from "@emotion/styled";
import { ArrowBackIosNewRounded } from "@mui/icons-material";
import { IconButton } from "@mui/material";
import { useNavigate } from "react-router-dom";
import { getFontColor } from "../utils";

interface TopBarProps {
  title: string;
}

/**
 * Component for displaying a top bar with a title and a back button.
 * @param {string} title - Title of page
 */
export const TopBar = ({ title }: TopBarProps) => {
  const n = useNavigate();
  return (
    <Container>
      <BackBtn size="large" aria-label="Back" onClick={() => n("/")}>
        <ArrowIcon />
      </BackBtn>
      <Title>{title}</Title>
    </Container>
  );
};

const Container = styled.div`
  margin: 0;
  width: 100%;
  position: sticky;
  top: 0;
  z-index: 99;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  background: ${({ theme }) => theme.secondary + "c1"};
  transition: background 0.3s, color 0.3s;
  margin-bottom: 48px;
`;

const ArrowIcon = styled(ArrowBackIosNewRounded)`
  color: ${({ theme }) => getFontColor(theme.secondary)};
`;

const Title = styled.h2`
  font-size: 28px;
  margin: 0 auto;
  text-align: center;
  padding: 4px 0 8px 0;
  text-shadow: 0 0 24px #00000068;
`;
const BackBtn = styled(IconButton)`
  position: absolute;
  color: ${({ theme }) => getFontColor(theme.secondary)};
  @media (max-width: 1024px) {
    margin-top: 4px;
  }
`;


// File: workspace/TodoApp/src/components/Toaster.tsx
import { useTheme } from "@emotion/react";
import { Toaster } from "react-hot-toast";
import { useResponsiveDisplay } from "../hooks/useResponsiveDisplay";
import { ColorPalette } from "../theme/themeConfig";
import { getFontColor } from "../utils";

export const CustomToaster = () => {
  const isMobile = useResponsiveDisplay();
  const theme = useTheme();
  return (
    <Toaster
      position="top-center"
      reverseOrder={false}
      gutter={12}
      containerStyle={{
        marginBottom: isMobile ? "96px" : "12px",
      }}
      toastOptions={{
        position: "bottom-center",
        duration: 4000,
        style: {
          padding: "14px 22px",
          borderRadius: "18px",
          fontSize: "17px",
          border: `2px solid ${theme.primary}`,
          background: theme.darkmode ? "#141431e0" : "#ffffff99",
          color: theme.darkmode ? ColorPalette.fontLight : ColorPalette.fontDark,
          WebkitBackdropFilter: `blur(${theme.darkmode ? "6" : "14"}px)`,
          backdropFilter: `blur(${theme.darkmode ? "6" : "14"}px)`,
        },
        success: {
          iconTheme: {
            primary: theme.primary,
            secondary: getFontColor(theme.primary),
          },
        },
        error: {
          iconTheme: {
            primary: ColorPalette.red,
            secondary: "white",
          },
          style: {
            borderColor: ColorPalette.red,
          },
        },
      }}
    />
  );
};


// File: workspace/TodoApp/src/components/EmojiPicker.tsx
import { useTheme } from "@emotion/react";
import styled from "@emotion/styled";
import { AddReaction, AutoAwesome, Edit, RemoveCircleOutline } from "@mui/icons-material";
import { Avatar, Badge, Button, CircularProgress } from "@mui/material";
import { Emoji, EmojiClickData, EmojiStyle, SuggestionMode, Theme } from "emoji-picker-react";
import {
  CSSProperties,
  Dispatch,
  SetStateAction,
  Suspense,
  lazy,
  useContext,
  useEffect,
  useState,
} from "react";
import { UserContext } from "../contexts/UserContext";
import { useOnlineStatus } from "../hooks/useOnlineStatus";
import { fadeIn } from "../styles";
import { ColorPalette } from "../theme/themeConfig";
import { getFontColor, showToast, systemInfo } from "../utils";

const EmojiPicker = lazy(() => import("emoji-picker-react"));
interface EmojiPickerProps {
  emoji?: string;
  //FIXME:
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setEmoji: Dispatch<SetStateAction<any>>;
  //TODO:
  // onEmojiChange: (emojiData: EmojiClickData) => void;
  color?: string;
  width?: CSSProperties["width"];
  name?: string;
}

export const CustomEmojiPicker = ({ emoji, setEmoji, color, width, name }: EmojiPickerProps) => {
  const { user, setUser } = useContext(UserContext);
  const { emojisStyle, settings } = user;
  const [showEmojiPicker, setShowEmojiPicker] = useState<boolean>(false);
  const [currentEmoji, setCurrentEmoji] = useState<string | null>(emoji || null);

  const isOnline = useOnlineStatus();
  const emotionTheme = useTheme();

  interface EmojiItem {
    unified: string;
    original: string;
    count: number;
  }

  const getFrequentlyUsedEmojis = (): string[] => {
    const frequentlyUsedEmojis: EmojiItem[] | null = JSON.parse(
      localStorage.getItem("epr_suggested") || "null"
    );

    if (!frequentlyUsedEmojis) {
      return [];
    }

    frequentlyUsedEmojis.sort((a: EmojiItem, b: EmojiItem) => b.count - a.count);
    const topEmojis: EmojiItem[] = frequentlyUsedEmojis.slice(0, 6);
    const topUnified: string[] = topEmojis.map((item: EmojiItem) => item.unified);

    return topUnified;
  };

  // When the currentEmoji state changes, update the parent component's emoji state
  useEffect(() => {
    setEmoji(currentEmoji);
  }, [currentEmoji, setEmoji]);

  // When the emoji prop changes to an empty string, set the currentEmoji state to undefined
  useEffect(() => {
    if (emoji === "") {
      setCurrentEmoji(null);
    }
  }, [emoji]);

  // Function to toggle the visibility of the EmojiPicker
  const toggleEmojiPicker = () => {
    setShowEmojiPicker((prevState) => !prevState);
  };

  // Handler function for when an emoji is clicked in the EmojiPicker
  const handleEmojiClick = (e: EmojiClickData) => {
    toggleEmojiPicker();
    setCurrentEmoji(e.unified);
    console.log(e);
  };

  const handleRemoveEmoji = () => {
    toggleEmojiPicker();
    setCurrentEmoji(null);
  };

  const [isAILoading, setIsAILoading] = useState<boolean>(false);
  // ‼ This feature works only in Chrome (Dev / Canary) version 127 or higher with some flags enabled
  async function useAI() {
    const start = new Date().getTime();
    setIsAILoading(true);
    //@ts-expect-error window.ai is an experimental chrome feature
    const session = window.ai.createTextSession();

    const sessionInstance = await session;

    const response = await sessionInstance.prompt(
      `Choose an emoji that best represents the task: ${name}. (For example: 🖥️ for coding, 📝 for writing, 🎨 for design) Type 'none' if not applicable.`
    );

    console.log("Full AI response:", response);
    // Validate if userInput is a valid emoji
    const emojiRegex =
      /[\u{1F300}-\u{1F6FF}\u{1F900}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/u;
    if (emojiRegex.test(response)) {
      setIsAILoading(false);

      const unified = emojiToUnified(response.trim().toLowerCase()).toLowerCase();
      console.log("Emoji unified:", unified);
      setCurrentEmoji(unified);
    } else {
      setCurrentEmoji(null);
      showToast(
        `Invalid emoji (response: ${response}). Please try again with different task name.`,
        { type: "error" }
      );
      console.error("Invalid emoji.");
    }
    const end = new Date().getTime();
    setIsAILoading(false);
    console.log(`%cTook ${end - start}ms to generate.`, "color: lime");
  }

  const emojiToUnified = (emoji: string): string => {
    const codePoints = [...emoji].map((char) => {
      if (char) {
        return char.codePointAt(0)?.toString(16).toUpperCase() ?? "";
      }
      return "";
    });
    return codePoints.join("-");
  };
  // end of AI experimental feature code

  // Function to render the content of the Avatar based on whether an emoji is selected or not
  const renderAvatarContent = () => {
    const fontColor = color ? getFontColor(color) : ColorPalette.fontLight;
    if (isAILoading) {
      return <CircularProgress size={40} thickness={5} sx={{ color: fontColor }} />;
    }
    if (currentEmoji) {
      const emojiSize =
        emojisStyle === EmojiStyle.NATIVE && systemInfo.os === "iOS"
          ? 64
          : emojisStyle === EmojiStyle.NATIVE
          ? 48
          : 64;

      return (
        <EmojiElement key={currentEmoji}>
          <Emoji size={emojiSize} emojiStyle={emojisStyle} unified={currentEmoji} />
        </EmojiElement>
      );
    } else {
      return (
        <AddReaction
          sx={{
            fontSize: "52px",
            color: fontColor,
            transition: ".3s all",
          }}
        />
      );
    }
  };

  return (
    <>
      <EmojiContainer>
        <Badge
          overlap="circular"
          anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
          badgeContent={
            <Avatar
              sx={{
                background: "#9c9c9c81",
                backdropFilter: "blur(6px)",
                cursor: "pointer",
              }}
              onClick={toggleEmojiPicker}
            >
              <Edit />
            </Avatar>
          }
        >
          <Avatar
            onClick={toggleEmojiPicker}
            sx={{
              width: "96px",
              height: "96px",
              background: color || emotionTheme.primary,
              transition: ".3s all",
              cursor: "pointer",
            }}
          >
            {renderAvatarContent()}
          </Avatar>
        </Badge>
      </EmojiContainer>
      {"ai" in window && name && (
        <Button
          onClick={useAI}
          disabled={name?.length < 5}
          style={{ width: "250px", height: "50px", marginBottom: "4px" }}
        >
          <AutoAwesome /> &nbsp; Find emoji with AI
        </Button>
      )}
      {showEmojiPicker && (
        <>
          {!isOnline && emojisStyle !== EmojiStyle.NATIVE && (
            <div
              style={{
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                maxWidth: width || "350px",
                margin: "6px auto -6px auto",
              }}
            >
              <span style={{ margin: 0, fontSize: "14px", textAlign: "center" }}>
                Emojis may not load correctly when offline. Try switching to the native emoji style.
                <br />
                <Button
                  variant="outlined"
                  onClick={() => {
                    setUser((prevUser) => ({
                      ...prevUser,
                      emojisStyle: EmojiStyle.NATIVE,
                    }));
                  }}
                  sx={{ borderRadius: "12px", p: "10px 20px", mt: "12px" }}
                >
                  Change Style
                </Button>
              </span>
            </div>
          )}

          <EmojiPickerContainer>
            <Suspense
              fallback={
                !settings[0].simpleEmojiPicker && (
                  <PickerLoader
                    pickerTheme={emotionTheme.darkmode ? "dark" : "light"}
                    width={width}
                  ></PickerLoader>
                )
              }
            >
              <EmojiPicker
                width={width || "350px"}
                height="500px"
                reactionsDefaultOpen={
                  settings[0].simpleEmojiPicker && getFrequentlyUsedEmojis().length !== 0
                }
                reactions={getFrequentlyUsedEmojis()}
                emojiStyle={emojisStyle}
                theme={emotionTheme.darkmode ? Theme.DARK : Theme.LIGHT}
                suggestedEmojisMode={SuggestionMode.FREQUENT}
                autoFocusSearch={false}
                onEmojiClick={handleEmojiClick}
                searchPlaceHolder="Search emoji"
                previewConfig={{
                  defaultEmoji: "1f4dd",
                  defaultCaption: "Choose the perfect emoji for your task",
                }}
              />
            </Suspense>
          </EmojiPickerContainer>
          {currentEmoji && (
            <div
              style={{
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                marginBottom: "14px",
              }}
            >
              <Button
                variant="outlined"
                color="error"
                onClick={handleRemoveEmoji}
                sx={{ p: "10px 20px", borderRadius: "12px" }}
              >
                <RemoveCircleOutline /> &nbsp; Remove Emoji
              </Button>
            </div>
          )}
        </>
      )}
    </>
  );
};

const EmojiContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 14px;
`;

const EmojiPickerContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 24px;
  animation: ${fadeIn} 0.4s ease-in;
`;

const PickerLoader = styled.div<{
  pickerTheme: "light" | "dark" | undefined;
  width: CSSProperties["width"] | undefined;
}>`
  display: flex;
  align-items: center;
  justify-content: center;
  width: ${({ width }) => width || "350px"};
  height: 500px;
  padding: 8px;
  border-radius: 20px;
  background: ${({ pickerTheme }) => (pickerTheme === "dark" ? "#222222" : "#ffffff")};
  border: ${({ pickerTheme }) => `1px solid ${pickerTheme === "dark" ? "#151617" : "#e7e7e7"}`};
`;

const EmojiElement = styled.div`
  animation: ${fadeIn} 0.4s ease-in;
`;


// File: workspace/TodoApp/src/components/BottomNav.tsx
import {
  AddRounded,
  CategoryRounded,
  GetAppRounded,
  PersonRounded,
  TaskAlt,
} from "@mui/icons-material";
import {
  Badge,
  BottomNavigation,
  BottomNavigationAction,
  Box,
  css,
  styled,
  useTheme,
} from "@mui/material";
import { useContext, useEffect, useState } from "react";
import { useLocation, useNavigate } from "react-router-dom";
import { UserContext } from "../contexts/UserContext";
import { useResponsiveDisplay } from "../hooks/useResponsiveDisplay";
import { pulseAnimation, slideInBottom } from "../styles";
import { getFontColor } from "../utils";

/**
 * Component for rendering the bottom navigation bar.
 */
export const BottomNav = (): JSX.Element | null => {
  const { user } = useContext(UserContext);
  const { tasks, settings } = user;
  const [value, setValue] = useState<number | undefined>();

  const theme = useTheme();
  const n = useNavigate();
  const isMobile = useResponsiveDisplay();
  const location = useLocation();

  const smallIconSize = "29px";

  // useEffect hook to set the active button based on the current route
  useEffect(() => {
    const pathParts = location.pathname.split("/"); // Split the pathname by '/'
    if (pathParts[1] === "task") {
      setValue(0); // If the user is on a task page, set the value to 0
    } else {
      // Handle other routes as before
      switch (location.pathname) {
        case "/categories":
          setValue(1);
          break;
        case "/add":
          setValue(2);
          break;
        case "/transfer":
          setValue(3);
          break;
        case "/user":
          setValue(4);
          break;
        case "/":
          setValue(0);
          break;
        default:
          setValue(undefined); // Fallback for the undefined route
      }
    }
  }, [location.pathname]);

  // If it's a mobile device, don't render the navigation bar.
  if (!isMobile) {
    return null;
  }

  return (
    <Container>
      <StyledBottomNavigation
        showLabels
        glow={settings[0].enableGlow}
        value={value}
        onChange={(_event, newValue: number) => {
          window.scrollTo({
            top: 0,
            behavior: "smooth",
          });
          setValue(newValue);
        }}
      >
        <NavigationButton
          onClick={() => n("/")}
          label="Tasks"
          icon={
            <Badge
              color="primary"
              badgeContent={value !== 0 ? tasks.filter((task) => !task.done).length : undefined}
              max={99}
            >
              <TaskAlt sx={{ fontSize: smallIconSize }} />
            </Badge>
          }
        />
        <NavigationButton
          onClick={() => n("/categories")}
          label="Categories"
          icon={<CategoryRounded sx={{ fontSize: smallIconSize }} />}
          disabled={!settings[0].enableCategories}
        />
        <NavigationButton
          onClick={() => n("add")}
          showLabel={false}
          aria-label="Add"
          icon={
            <AddIcon
              clr={theme.palette.primary.main}
              fontSize="large"
              animate={tasks.length === 0 && value !== 2}
            />
          }
        />
        <NavigationButton
          onClick={() => n("transfer")}
          label="Transfer"
          icon={<GetAppRounded sx={{ fontSize: smallIconSize }} />}
        />
        <NavigationButton
          onClick={() => n("user")}
          label="Profile"
          icon={<PersonRounded sx={{ fontSize: smallIconSize }} />}
        />
      </StyledBottomNavigation>
    </Container>
  );
};

const AddIcon = styled(AddRounded)<{ clr: string; animate: boolean }>`
  border: 2px solid ${({ clr }) => clr};
  background-color: ${({ theme }) => theme.palette.secondary.main};
  font-size: 38px;
  border-radius: 100px;
  padding: 6px;
  margin: 14px;
  transition: background 0.3s;
  ${({ animate, theme }) =>
    animate &&
    css`
      animation: ${pulseAnimation(theme.palette.primary.main, 10)} 1.2s infinite;
    `};
`;

const Container = styled(Box)`
  position: fixed;
  bottom: 0;
  width: 100%;
  margin: 0;
  animation: ${slideInBottom} 0.5s ease;
  z-index: 999;
`;

const StyledBottomNavigation = styled(BottomNavigation)<{ glow: boolean }>`
  border-radius: 24px 24px 0 0;
  background: ${({ theme, glow }) => `${theme.palette.secondary.main}${glow ? "c8" : "e6"}`};
  backdrop-filter: blur(20px);
  margin: 0px 20px 0px -20px;
  padding: 18px 10px 32px 10px;
  transition: 0.3s background, color;
`;

const NavigationButton = styled(BottomNavigationAction)`
  border-radius: 18px;
  margin: 4px;
  color: ${({ theme }) => getFontColor(theme.palette.secondary.main)};

  &:disabled {
    opacity: 0.6;
    & .MuiBottomNavigationAction-label {
      text-shadow: none;
    }
  }

  & .MuiBottomNavigationAction-label {
    font-size: 13px !important;
  }
`;


// File: workspace/TodoApp/src/components/EditTask.tsx
import styled from "@emotion/styled";
import { CancelRounded, EditCalendarRounded, SaveRounded } from "@mui/icons-material";
import {
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  IconButton,
  InputAdornment,
  TextField,
  Tooltip,
} from "@mui/material";
import { useContext, useEffect, useMemo, useState } from "react";
import { CategorySelect, ColorPicker, CustomEmojiPicker } from ".";
import { DESCRIPTION_MAX_LENGTH, TASK_NAME_MAX_LENGTH } from "../constants";
import { UserContext } from "../contexts/UserContext";
import { DialogBtn } from "../styles";
import { Category, Task } from "../types/user";
import { showToast, timeAgo } from "../utils";
import { useTheme } from "@emotion/react";
import { ColorPalette } from "../theme/themeConfig";

interface EditTaskProps {
  open: boolean;
  task?: Task;
  onClose: () => void;
  onSave: (editedTask: Task) => void;
}

export const EditTask = ({ open, task, onClose, onSave }: EditTaskProps) => {
  const { user } = useContext(UserContext);
  const { settings } = user;
  const [editedTask, setEditedTask] = useState<Task | undefined>(task);
  const [emoji, setEmoji] = useState<string | undefined>();
  const [selectedCategories, setSelectedCategories] = useState<Category[]>([]);

  const theme = useTheme();

  const nameError = useMemo(
    () => (editedTask?.name ? editedTask.name.length > TASK_NAME_MAX_LENGTH : undefined),
    [editedTask?.name]
  );
  const descriptionError = useMemo(
    () =>
      editedTask?.description ? editedTask.description.length > DESCRIPTION_MAX_LENGTH : undefined,
    [editedTask?.description]
  );

  // const isMobile = useResponsiveDisplay(600);

  // Effect hook to update the editedTask with the selected emoji.
  useEffect(() => {
    setEditedTask((prevTask) => ({
      ...(prevTask as Task),
      emoji: emoji,
    }));
  }, [emoji]);

  // Effect hook to update the editedTask when the task prop changes.
  useEffect(() => {
    setEditedTask(task);
    setSelectedCategories(task?.category as Category[]);
  }, [task]);

  // Event handler for input changes in the form fields.
  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = event.target;

    // Update the editedTask state with the changed value.
    setEditedTask((prevTask) => ({
      ...(prevTask as Task),
      [name]: value,
    }));
  };
  // Event handler for saving the edited task.
  const handleSave = () => {
    document.body.style.overflow = "auto";
    if (editedTask && !nameError && !descriptionError) {
      onSave(editedTask);
      showToast(
        <div>
          Task <b translate="no">{editedTask.name}</b> updated.
        </div>
      );
    }
  };

  const handleCancel = () => {
    onClose();
    setEditedTask(task);
    setSelectedCategories(task?.category as Category[]);
  };

  useEffect(() => {
    setEditedTask((prevTask) => ({
      ...(prevTask as Task),
      category: (selectedCategories as Category[]) || undefined,
    }));
  }, [selectedCategories]);

  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (JSON.stringify(editedTask) !== JSON.stringify(task) && open) {
        const message = "You have unsaved changes. Are you sure you want to leave?";
        e.returnValue = message;
        return message;
      }
    };

    window.addEventListener("beforeunload", handleBeforeUnload);

    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    };
  }, [editedTask, open, task]);

  return (
    <Dialog
      open={open}
      // fullScreen={isMobile}
      onClose={() => {
        onClose();
        // setEditedTask(task);
        // setSelectedCategories(task?.category as Category[]);
      }}
      PaperProps={{
        style: {
          // borderRadius: !isMobile ? "24px" : 0,
          borderRadius: "24px",
          padding: "12px",
          maxWidth: "600px",
        },
      }}
    >
      <DialogTitle
        sx={{
          justifyContent: "space-between",
          display: "flex",
          alignItems: "center",
        }}
      >
        <span>Edit Task</span>
        {editedTask?.lastSave && (
          <Tooltip title={timeAgo(editedTask.lastSave)}>
            <LastEdit>
              <EditCalendarRounded sx={{ fontSize: "20px" }} /> Last Edited:{" "}
              {new Date(editedTask.lastSave).toLocaleDateString()}
              {" • "}
              {new Date(editedTask.lastSave).toLocaleTimeString()}
            </LastEdit>
          </Tooltip>
        )}
      </DialogTitle>
      <DialogContent>
        <CustomEmojiPicker
          emoji={editedTask?.emoji || undefined}
          setEmoji={setEmoji}
          color={editedTask?.color}
          width="350px"
        />
        <StyledInput
          label="Name"
          name="name"
          autoComplete="off"
          value={editedTask?.name || ""}
          onChange={handleInputChange}
          error={nameError || editedTask?.name === ""}
          helperText={
            editedTask?.name
              ? editedTask?.name.length === 0
                ? "Name is required"
                : editedTask?.name.length > TASK_NAME_MAX_LENGTH
                ? `Name is too long (maximum ${TASK_NAME_MAX_LENGTH} characters)`
                : `${editedTask?.name?.length}/${TASK_NAME_MAX_LENGTH}`
              : "Name is required"
          }
        />
        <StyledInput
          label="Description"
          name="description"
          autoComplete="off"
          value={editedTask?.description || ""}
          onChange={handleInputChange}
          multiline
          rows={4}
          margin="normal"
          error={descriptionError}
          helperText={
            editedTask?.description === "" || editedTask?.description === undefined
              ? undefined
              : descriptionError
              ? `Description is too long (maximum ${DESCRIPTION_MAX_LENGTH} characters)`
              : `${editedTask?.description?.length}/${DESCRIPTION_MAX_LENGTH}`
          }
        />

        <StyledInput
          label="Deadline date"
          name="deadline"
          type="datetime-local"
          value={editedTask?.deadline || ""}
          onChange={handleInputChange}
          defaultValue=""
          InputLabelProps={{ shrink: true }}
          sx={{
            colorScheme: theme.darkmode ? "dark" : "light",
            " & .MuiInputBase-root": {
              transition: ".3s all",
            },
          }}
          InputProps={{
            startAdornment: editedTask?.deadline ? (
              <InputAdornment position="start">
                <Tooltip title="Clear">
                  <IconButton
                    color="error"
                    onClick={() => {
                      setEditedTask((prevTask) => ({
                        ...(prevTask as Task),
                        deadline: undefined,
                      }));
                    }}
                  >
                    <CancelRounded />
                  </IconButton>
                </Tooltip>
              </InputAdornment>
            ) : undefined,
          }}
        />
        {settings[0].enableCategories !== undefined && settings[0].enableCategories && (
          <CategorySelect
            fontColor={theme.darkmode ? ColorPalette.fontLight : ColorPalette.fontDark}
            selectedCategories={selectedCategories}
            onCategoryChange={(categories) => setSelectedCategories(categories)}
          />
        )}
        <div
          style={{
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            marginTop: "8px",
          }}
        >
          <ColorPicker
            width={"100%"}
            color={editedTask?.color || "#000000"}
            fontColor={theme.darkmode ? ColorPalette.fontLight : ColorPalette.fontDark}
            onColorChange={(color) => {
              setEditedTask((prevTask) => ({
                ...(prevTask as Task),
                color: color,
              }));
            }}
          />
        </div>
      </DialogContent>
      <DialogActions>
        <DialogBtn onClick={handleCancel}>Cancel</DialogBtn>
        <DialogBtn
          onClick={handleSave}
          color="primary"
          disabled={
            nameError ||
            editedTask?.name === "" ||
            descriptionError ||
            nameError ||
            JSON.stringify(editedTask) === JSON.stringify(task)
          }
        >
          <SaveRounded /> &nbsp; Save
        </DialogBtn>
      </DialogActions>
    </Dialog>
  );
};

const StyledInput = styled(TextField)`
  margin: 14px 0;
  & .MuiInputBase-root {
    border-radius: 16px;
  }
`;
StyledInput.defaultProps = {
  fullWidth: true,
};

const LastEdit = styled.span`
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 15px;
  font-style: italic;
  font-weight: 400;
  opacity: 0.8;
  @media (max-width: 768px) {
    font-size: 14px;
  }
`;


// File: workspace/TodoApp/src/components/CategoryBadge.tsx
import { Avatar, Chip, ChipProps, styled } from "@mui/material";
import { Emoji, EmojiStyle } from "emoji-picker-react";
import { useContext } from "react";
import { UserContext } from "../contexts/UserContext";
import { fadeIn } from "../styles";
import type { Category } from "../types/user";
import { getFontColor } from "../utils";

interface CategoryBadgeProps extends ChipProps, StyledBadgeProps {
  category: Category;
  /**
   * Array representing emoji sizes: [normal, native]
   */
  emojiSizes?: [number, number];
}
/**
 * Component for displaying a category badge.
 */
export const CategoryBadge: React.FC<CategoryBadgeProps> = ({ category, emojiSizes, ...props }) => {
  const { user } = useContext(UserContext);
  const { emojisStyle, settings } = user;

  return (
    <StyledCategoryBadge
      key={category.id}
      label={category.name}
      variant="outlined"
      backgroundclr={category.color}
      glow={settings[0].enableGlow}
      translate="no"
      avatar={
        category.emoji ? (
          <Avatar
            alt={category.name}
            sx={{
              background: "transparent",
              borderRadius: "0px",
            }}
          >
            <Emoji
              lazyLoad
              size={
                emojiSizes
                  ? emojisStyle !== EmojiStyle.NATIVE
                    ? emojiSizes[0]
                    : emojiSizes[1]
                  : 20
              }
              unified={category.emoji}
              emojiStyle={emojisStyle}
            />
          </Avatar>
        ) : undefined
      }
      {...props}
    />
  );
};

interface StyledBadgeProps {
  backgroundclr?: string;
  borderclr?: string;
  glow?: boolean;
  list?: boolean | string;
}

export const StyledCategoryBadge = styled(Chip)<StyledBadgeProps>`
  color: ${({ backgroundclr }) => getFontColor(backgroundclr || "")};
  background-color: ${({ backgroundclr }) => backgroundclr};
  box-shadow: ${({ glow, backgroundclr }) => (glow ? `0 0 8px 0 ${backgroundclr}` : "none")};
  border: ${({ borderclr }) => (borderclr ? `2px solid ${borderclr}` : "none")};
  font-weight: bold;
  font-size: 14px;
  margin: 6px 0 0 0;
  padding: 8px;
  transition: 0.3s all;
  /* opacity: ${({ list }) => (list ? 1 : 0.9)}; */
  animation: ${fadeIn} 0.5s ease-in;

  &:hover {
    background-color: ${(props) => props.backgroundclr + "!important"};
    /* box-shadow: ${({ list, backgroundclr }) => list && `0 0 8px 0px ${backgroundclr}`}; */
    opacity: ${({ list }) => list && 0.8};
  }

  &:focus-visible {
    opacity: 0.8;
    background-color: ${({ backgroundclr }) => backgroundclr};
  }
  &:focus {
    opacity: none;
  }

  & .MuiChip-deleteIcon {
    color: ${({ backgroundclr }) => getFontColor(backgroundclr || "")};
    transition: 0.3s all;
    width: 22px;
    height: 22px;
    stroke: transparent;
    @media (max-width: 1024px) {
      width: 26px;
      height: 26px;
    }
    &:hover {
      color: ${({ backgroundclr }) => getFontColor(backgroundclr || "")};
      opacity: 0.8;
    }
  }
`;


// File: workspace/TodoApp/src/components/Loading.tsx
import styled from "@emotion/styled";
import { Box, CircularProgress } from "@mui/material";
import { useEffect, useState } from "react";

export const Loading = () => {
  const [showLoading, setShowLoading] = useState<boolean>(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setShowLoading(true);
    }, 100); // Show the loading spinner after 100 milliseconds

    return () => clearTimeout(timer);
  }, []);

  return (
    <Container>
      {showLoading && (
        <>
          <CircularProgress size={80} thickness={4} aria-label="loading" />
        </>
      )}
    </Container>
  );
};

const Container = styled(Box)`
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  text-align: center;
  gap: 8px;
`;


// File: workspace/TodoApp/src/components/Sidebar.tsx
import styled from "@emotion/styled";
import {
  AddRounded,
  AdjustRounded,
  BugReportRounded,
  CategoryRounded,
  DeleteForeverRounded,
  Favorite,
  FavoriteRounded,
  FiberManualRecord,
  GetAppRounded,
  GitHub,
  InstallDesktopRounded,
  InstallMobileRounded,
  IosShareRounded,
  Logout,
  PhoneIphoneRounded,
  SettingsRounded,
  StarRounded,
  TaskAltRounded,
} from "@mui/icons-material";
import {
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Divider,
  IconButton,
  MenuItem,
  SwipeableDrawer,
  Tooltip,
} from "@mui/material";
import React, { useContext, useEffect, useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { SettingsDialog } from ".";
import bmcLogo from "../assets/bmc-logo.svg";
import bmcLogoLight from "../assets/bmc-logo-light.svg";
import logo from "../assets/logo256.png";
import { defaultUser } from "../constants/defaultUser";
import { UserContext } from "../contexts/UserContext";
import { fetchBMCInfo } from "../services/bmcApi";
import { fetchGitHubInfo } from "../services/githubApi";
import { DialogBtn, UserAvatar, pulseAnimation, ring } from "../styles";
import { showToast, systemInfo, timeAgo } from "../utils";
import { useTheme } from "@emotion/react";
import { ColorPalette } from "../theme/themeConfig";

export const ProfileSidebar = () => {
  const { user, setUser } = useContext(UserContext);
  const { name, profilePicture, tasks, settings } = user;
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const open = Boolean(anchorEl);
  const [logoutConfirmationOpen, setLogoutConfirmationOpen] = useState<boolean>(false);
  const [openSettings, setOpenSettings] = useState<boolean>(false);

  const [stars, setStars] = useState<number | null>(null);
  const [lastUpdate, setLastUpdate] = useState<string | null>(null);
  const [issuesCount, setIssuesCount] = useState<number | null>(null);

  const [bmcSupporters, setBmcSupporters] = useState<number | null>(null);

  const theme = useTheme();
  const n = useNavigate();

  useEffect(() => {
    const fetchRepoInfo: () => Promise<void> = async () => {
      const { repoData, branchData } = await fetchGitHubInfo();
      setStars(repoData.stargazers_count);
      setLastUpdate(branchData.commit.commit.committer.date);
      setIssuesCount(repoData.open_issues_count);
    };

    const fetchBMC: () => Promise<void> = async () => {
      // Fetch data from the Buy Me a Coffee API
      const { supportersCount } = await fetchBMCInfo();
      // In case BMC api fails
      if (supportersCount > 0) {
        setBmcSupporters(supportersCount);
      } else {
        console.error("No BMC supporters found.");
      }
    };

    fetchBMC();
    fetchRepoInfo();
  }, []);

  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleLogoutConfirmationOpen = () => {
    setLogoutConfirmationOpen(true);
    setAnchorEl(null);
  };

  const handleLogoutConfirmationClose = () => {
    setLogoutConfirmationOpen(false);
  };

  const handleLogout = () => {
    setUser(defaultUser);
    handleLogoutConfirmationClose();
    showToast("You have been successfully logged out");
  };

  interface BeforeInstallPromptEvent extends Event {
    readonly platforms: ReadonlyArray<string>;
    readonly userChoice: Promise<{
      outcome: "accepted" | "dismissed";
      platform: string;
    }>;
    prompt(): Promise<void>;
  }

  const [supportsPWA, setSupportsPWA] = useState<boolean>(false);
  const [deferredPrompt, setDeferredPrompt] = useState<BeforeInstallPromptEvent | null>(null);
  const [isAppInstalled, setIsAppInstalled] = useState<boolean>(false);

  useEffect(() => {
    const beforeInstallPromptHandler = (e: Event) => {
      e.preventDefault();
      setSupportsPWA(true);
      setDeferredPrompt(e as BeforeInstallPromptEvent);
    };

    const detectAppInstallation = () => {
      window.matchMedia("(display-mode: standalone)").addEventListener("change", (e) => {
        setIsAppInstalled(e.matches);
      });
    };

    window.addEventListener("beforeinstallprompt", beforeInstallPromptHandler);
    detectAppInstallation();

    return () => {
      window.removeEventListener("beforeinstallprompt", beforeInstallPromptHandler);
    };
  }, []);

  const installPWA = () => {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      deferredPrompt.userChoice.then((choiceResult) => {
        if (choiceResult.outcome === "accepted") {
          showToast("App installed successfully!");
          if ("setAppBadge" in navigator) {
            setUser((prevUser) => ({
              ...prevUser,
              settings: [
                {
                  ...prevUser.settings[0],
                  appBadge: true,
                },
              ],
            }));
          }
          handleClose();
        }
        if (choiceResult.outcome === "dismissed") {
          showToast("Installation dismissed.", { type: "error" });
        }
      });
    }
  };

  return (
    <Container>
      <Tooltip title={<div translate={name ? "no" : "yes"}>{name || "User"}</div>}>
        <IconButton
          aria-label="Sidebar"
          aria-controls={open ? "basic-menu" : undefined}
          aria-haspopup="true"
          aria-expanded={open ? "true" : undefined}
          onClick={handleClick}
          sx={{ zIndex: 1 }}
        >
          <UserAvatar
            src={(profilePicture as string) || undefined}
            alt={name || "User"}
            hasImage={profilePicture !== null}
            size="52px"
            onError={() => {
              // This prevents the error handling from being called unnecessarily when offline
              if (!navigator.onLine) return;
              setUser((prevUser) => ({
                ...prevUser,
                profilePicture: null,
              }));
              showToast("Error in profile picture URL", { type: "error" });
              throw new Error("Error in profile picture URL");
            }}
          >
            {name ? name[0].toUpperCase() : undefined}
          </UserAvatar>
        </IconButton>
      </Tooltip>
      <StyledSwipeableDrawer
        disableBackdropTransition={systemInfo.os !== "iOS"}
        disableDiscovery={systemInfo.os === "iOS"}
        id="basic-menu"
        anchor="right"
        open={open}
        onOpen={(e) => e.preventDefault()}
        onClose={handleClose}
      >
        <LogoContainer
          translate="no"
          onClick={() => {
            n("/");
            handleClose();
          }}
        >
          <Logo src={logo} alt="logo" />
          <LogoText>
            <span>Todo</span> App
            <span>.</span>
          </LogoText>
        </LogoContainer>

        <MenuLink to="/">
          <StyledMenuItem onClick={handleClose}>
            <TaskAltRounded /> &nbsp; Tasks
            {tasks.filter((task) => !task.done).length > 0 && (
              <Tooltip title={`${tasks.filter((task) => !task.done).length} tasks to do`}>
                <MenuLabel>
                  {tasks.filter((task) => !task.done).length > 99
                    ? "99+"
                    : tasks.filter((task) => !task.done).length}
                </MenuLabel>
              </Tooltip>
            )}
          </StyledMenuItem>
        </MenuLink>

        <MenuLink to="/add">
          <StyledMenuItem onClick={handleClose}>
            <AddRounded /> &nbsp; Add Task
          </StyledMenuItem>
        </MenuLink>

        <MenuLink to="/purge">
          <StyledMenuItem onClick={handleClose}>
            <DeleteForeverRounded /> &nbsp; Purge Tasks
          </StyledMenuItem>
        </MenuLink>

        {settings[0].enableCategories !== undefined && settings[0].enableCategories && (
          <MenuLink to="/categories">
            <StyledMenuItem onClick={handleClose}>
              <CategoryRounded /> &nbsp; Categories
            </StyledMenuItem>
          </MenuLink>
        )}

        <MenuLink to="/transfer">
          <StyledMenuItem onClick={handleClose}>
            <GetAppRounded /> &nbsp; Transfer
          </StyledMenuItem>
        </MenuLink>

        <StyledDivider />

        <MenuLink to="https://github.com/maciekt07/TodoApp">
          <StyledMenuItem translate="no">
            <GitHub /> &nbsp; Github{" "}
            {stars && (
              <Tooltip title={`${stars} stars on Github`}>
                <MenuLabel clr="#ff9d00">
                  <span style={{ display: "flex", alignItems: "center", justifyContent: "center" }}>
                    <StarRounded style={{ fontSize: "18px" }} />
                    &nbsp;{stars}
                  </span>
                </MenuLabel>
              </Tooltip>
            )}
          </StyledMenuItem>
        </MenuLink>

        <MenuLink to="https://github.com/maciekt07/TodoApp/issues/new">
          <StyledMenuItem>
            <BugReportRounded /> &nbsp; Report Issue{" "}
            {Boolean(issuesCount || issuesCount === 0) && (
              <Tooltip title={`${issuesCount} open issues`}>
                <MenuLabel clr="#3bb61c">
                  <span style={{ display: "flex", alignItems: "center", justifyContent: "center" }}>
                    <AdjustRounded style={{ fontSize: "18px" }} />
                    &nbsp;
                    {issuesCount}
                  </span>
                </MenuLabel>
              </Tooltip>
            )}
          </StyledMenuItem>
        </MenuLink>

        <MenuLink to="https://www.buymeacoffee.com/maciekt07">
          <StyledMenuItem className="bmcMenu">
            <BmcIcon className="bmc-icon" src={theme.darkmode ? bmcLogoLight : bmcLogo} /> &nbsp;
            Buy me a coffee{" "}
            {bmcSupporters && (
              <Tooltip title={`${bmcSupporters} supporters on Buy me a coffee`}>
                <MenuLabel clr="#f93c58">
                  <span style={{ display: "flex", alignItems: "center", justifyContent: "center" }}>
                    <FavoriteRounded style={{ fontSize: "16px" }} />
                    &nbsp;{bmcSupporters}
                  </span>
                </MenuLabel>
              </Tooltip>
            )}
          </StyledMenuItem>
        </MenuLink>

        <StyledDivider />

        {supportsPWA && !isAppInstalled && (
          <StyledMenuItem onClick={installPWA}>
            {systemInfo.os === "Android" ? <InstallMobileRounded /> : <InstallDesktopRounded />}
            &nbsp; Install App
          </StyledMenuItem>
        )}

        {systemInfo.browser === "Safari" &&
          systemInfo.os === "iOS" &&
          !window.matchMedia("(display-mode: standalone)").matches && (
            <StyledMenuItem
              onClick={() => {
                showToast(
                  <div style={{ display: "inline-block" }}>
                    To install the app on iOS Safari, click on{" "}
                    <IosShareRounded sx={{ verticalAlign: "middle", mb: "4px" }} /> and then{" "}
                    <span style={{ fontWeight: "bold" }}>Add to Home Screen</span>.
                  </div>,
                  { type: "blank", duration: 8000 }
                );
                handleClose();
              }}
            >
              <PhoneIphoneRounded />
              &nbsp; Install App
            </StyledMenuItem>
          )}

        <StyledMenuItem onClick={handleLogoutConfirmationOpen} sx={{ color: "#ff4040 !important" }}>
          <Logout /> &nbsp; Logout
        </StyledMenuItem>

        <ProfileOptionsBottom>
          <SettingsMenuItem
            onClick={() => {
              setOpenSettings(true);
              handleClose();
            }}
          >
            <SettingsRounded /> &nbsp; Settings
            {settings[0] === defaultUser.settings[0] && <PulseMenuLabel />}
          </SettingsMenuItem>

          <StyledDivider />
          <MenuLink to="/user">
            <ProfileMenuItem translate={name ? "no" : "yes"} onClick={handleClose}>
              <UserAvatar
                src={(profilePicture as string) || undefined}
                hasImage={profilePicture !== null}
                size="44px"
              >
                {name ? name[0].toUpperCase() : undefined}
              </UserAvatar>
              <h4 style={{ margin: 0, fontWeight: 600 }}> {name || "User"}</h4>{" "}
              {(name === null || name === "") &&
                profilePicture === null &&
                user.theme! == defaultUser.theme && <PulseMenuLabel />}
            </ProfileMenuItem>
          </MenuLink>

          <StyledDivider />

          <CreditsContainer translate="no">
            <span style={{ display: "flex", alignItems: "center" }}>
              Made with &nbsp;
              <Favorite sx={{ fontSize: "14px" }} />
            </span>
            <span style={{ marginLeft: "6px", marginRight: "4px" }}>by</span>
            <a
              style={{ textDecoration: "none", color: "inherit" }}
              href="https://github.com/maciekt07"
            >
              maciekt07
            </a>
          </CreditsContainer>
          <CreditsContainer>
            {lastUpdate && (
              <Tooltip title={timeAgo(new Date(lastUpdate))}>
                <span>
                  Last update:{" "}
                  {new Intl.DateTimeFormat(navigator.language, {
                    dateStyle: "long",
                    timeStyle: "medium",
                  }).format(new Date(lastUpdate))}
                </span>
              </Tooltip>
            )}
          </CreditsContainer>
        </ProfileOptionsBottom>
      </StyledSwipeableDrawer>

      <Dialog open={logoutConfirmationOpen} onClose={handleLogoutConfirmationClose}>
        <DialogTitle>Logout Confirmation</DialogTitle>
        <DialogContent>
          Are you sure you want to logout? <b>Your tasks will not be saved.</b>
        </DialogContent>
        <DialogActions>
          <DialogBtn onClick={handleLogoutConfirmationClose}>Cancel</DialogBtn>
          <DialogBtn onClick={handleLogout} color="error">
            <Logout /> &nbsp; Logout
          </DialogBtn>
        </DialogActions>
      </Dialog>
      <SettingsDialog open={openSettings} onClose={() => setOpenSettings(!openSettings)} />
    </Container>
  );
};

const MenuLink = ({ to, children }: { to: string; children: React.ReactNode }) => {
  const styles: React.CSSProperties = { borderRadius: "14px" };
  if (to.startsWith("/")) {
    return (
      // React Router Link component for internal navigation
      <Link to={to} style={styles}>
        {children}
      </Link>
    );
  }
  // Render an anchor tag for external navigation
  return (
    <a href={to} target="_blank" style={styles}>
      {children}
    </a>
  );
};

const Container = styled.div`
  position: absolute;
  right: 16vw;
  top: 14px;
  z-index: 900;
  @media (max-width: 1024px) {
    right: 16px;
  }
`;

const StyledSwipeableDrawer = styled(SwipeableDrawer)`
  & .MuiPaper-root {
    border-radius: 24px 0 0 0;
    min-width: 300px;
    box-shadow: none;
    padding: 4px 12px;
    color: ${({ theme }) => (theme.darkmode ? ColorPalette.fontLight : "#101727")};
    z-index: 999;

    @media (min-width: 1920px) {
      min-width: 310px;
    }

    @media (max-width: 1024px) {
      min-width: 270px;
    }

    @media (max-width: 600px) {
      min-width: 55vw;
    }
  }
`;

const StyledMenuItem = styled(MenuItem)`
  /* margin: 0px 8px; */
  padding: 16px 12px;
  border-radius: 14px;
  box-shadow: none;
  font-weight: 500;
  gap: 6px;

  & svg,
  .bmc-icon {
    transition: 0.4s transform;
  }

  &:hover {
    & svg[data-testid="GitHubIcon"] {
      transform: rotateY(${2 * Math.PI}rad);
    }
    & svg[data-testid="BugReportRoundedIcon"] {
      transform: rotate(45deg) scale(0.9) translateY(-20%);
    }
    & .bmc-icon {
      animation: ${ring} 2.5s ease-in alternate;
    }
  }
`;

const SettingsMenuItem = styled(StyledMenuItem)`
  background: ${({ theme }) => (theme.darkmode ? "#1f1f1f" : "#101727")};
  color: ${ColorPalette.fontLight} !important;
  margin-top: 8px !important;
  &:hover {
    background: ${({ theme }) => (theme.darkmode ? "#1f1f1fb2" : "#101727b2")};
    & svg[data-testid="SettingsRoundedIcon"] {
      transform: rotate(180deg);
    }
  }
`;

const ProfileMenuItem = styled(StyledMenuItem)`
  display: flex;
  align-items: center;
  gap: 10px;
  background: ${({ theme }) => (theme.darkmode ? "#1f1f1f" : "#d7d7d7")};
  &:hover {
    background: ${({ theme }) => (theme.darkmode ? "#1f1f1fb2" : "#d7d7d7b2")};
  }
`;

const MenuLabel = styled.span<{ clr?: string }>`
  margin-left: auto;
  font-weight: 600;
  background: ${({ clr, theme }) => (clr || theme.primary) + "35"};
  color: ${({ clr, theme }) => clr || theme.primary};
  padding: 2px 12px;
  border-radius: 32px;
  font-size: 14px;
`;

const StyledDivider = styled(Divider)`
  margin: 8px 4px;
`;

const PulseMenuLabel = styled(MenuLabel)`
  animation: ${({ theme }) => pulseAnimation(theme.primary, 6)} 1.2s infinite;
  padding: 6px;
  margin-right: 4px;
`;

PulseMenuLabel.defaultProps = {
  children: (
    <div
      style={{
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
      }}
    >
      <FiberManualRecord style={{ fontSize: "16px" }} />
    </div>
  ),
};

const LogoContainer = styled.div`
  display: flex;
  align-items: center;
  flex-direction: row;
  margin-top: 8px;
  margin-bottom: 16px;
  gap: 12px;
  cursor: pointer;
`;

const Logo = styled.img`
  width: 52px;
  height: 52px;
  margin-left: 12px;
  border-radius: 14px;
`;

const LogoText = styled.h2`
  & span {
    color: ${({ theme }) => theme.primary};
  }
`;

const BmcIcon = styled.img`
  width: 1em;
  height: 1em;
  font-size: 1.5rem;
`;

const ProfileOptionsBottom = styled.div`
  margin-top: auto;
  margin-bottom: ${window.matchMedia("(display-mode: standalone)").matches &&
  /Mobi/.test(navigator.userAgent)
    ? "38px"
    : "16px"};
  display: flex;
  flex-direction: column;
  gap: 8px;
`;

const CreditsContainer = styled.div`
  font-size: 12px;
  margin: 0;
  opacity: 0.8;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  & span {
    backdrop-filter: none !important;
  }
`;


// File: workspace/TodoApp/src/components/index.ts
export { TasksList } from "./tasks/TasksList";
export { ProfileSidebar } from "./Sidebar";
export { EditTask } from "./EditTask";
export { TopBar } from "./TopBar";
export { CustomEmojiPicker } from "./EmojiPicker";
export { SettingsDialog } from "./Settings";
export { TaskMenu } from "./tasks/TaskMenu";
export { BottomNav } from "./BottomNav";
export { CategorySelect } from "./CategorySelect";
export { ColorPicker } from "./ColorPicker";
export { CategoryBadge } from "./CategoryBadge";
export { TaskIcon } from "./TaskIcon";
export { Loading } from "./Loading";


// File: workspace/TodoApp/src/components/ColorPicker.tsx
import { useTheme } from "@emotion/react";
import styled from "@emotion/styled";
import {
  AddRounded,
  ColorizeRounded,
  DoneRounded,
  ExpandMoreRounded,
  InfoRounded,
} from "@mui/icons-material";
import {
  Accordion,
  AccordionDetails,
  AccordionSummary,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Grid,
  Popover,
  Tooltip,
} from "@mui/material";
import { getColorName } from "ntc-ts";
import { CSSProperties, useCallback, useContext, useEffect, useRef, useState } from "react";
import { type ToastOptions } from "react-hot-toast";
import { MAX_COLORS_IN_LIST } from "../constants";
import { UserContext } from "../contexts/UserContext";
import { ColorElement, DialogBtn, scale } from "../styles";
import { ColorPalette } from "../theme/themeConfig";
import { getFontColor, showToast } from "../utils";

interface ColorPickerProps {
  color: string;
  onColorChange: (newColor: string) => void;
  width?: CSSProperties["width"];
  fontColor?: CSSProperties["color"];
  label?: string;
}

/**
 * Custom Color Picker component for selecting colors.
 */

export const ColorPicker: React.FC<ColorPickerProps> = ({
  color,
  onColorChange,
  width,
  fontColor,
  label,
}) => {
  const { user, setUser } = useContext(UserContext);
  const { colorList } = user;
  const [selectedColor, setSelectedColor] = useState<string>(color);
  const [accordionExpanded, setAccordionExpanded] = useState<boolean>(false);

  const [popoverOpen, setPopoverOpen] = useState<boolean[]>(Array(colorList.length).fill(false));
  const [openAddDialog, setOpenAddDialog] = useState<boolean>(false);
  const [addColorVal, setAddColorVal] = useState<string>(color);
  const colorElementRefs = useRef<Array<HTMLElement | null>>([]);

  const theme = useTheme();

  const isHexColor = (value: string): boolean => /^#[0-9A-Fa-f]{6}$/.test(value);

  useEffect(() => {
    // Update the selected color when the color prop changes
    setSelectedColor(color);
  }, [color]);

  const handleColorChange = useCallback(
    (color: string) => {
      setSelectedColor(color);
      onColorChange(color);
    },
    [onColorChange]
  );

  // Check if the current color is a valid hex color and update it if not
  useEffect(() => {
    if (!isHexColor(color)) {
      handleColorChange(theme.primary);
      setSelectedColor(theme.primary);
      console.error("Invalid hex color " + color);
    }
  }, [color, handleColorChange, theme.primary]);

  const handleAccordionChange = (
    _event: React.SyntheticEvent<Element, Event>,
    isExpanded: boolean
  ) => setAccordionExpanded(isExpanded);

  const togglePopover = (index: number) => {
    const newPopoverOpen = [...popoverOpen];
    newPopoverOpen[index] = !newPopoverOpen[index];
    setPopoverOpen(newPopoverOpen);
  };

  const handleAddDialogOpen = () => {
    setOpenAddDialog(true);
    setAddColorVal(selectedColor);
  };

  const handleAddDialogClose = () => {
    setOpenAddDialog(false);
    setAddColorVal(selectedColor);
  };

  const handlePickerChange = (e: React.ChangeEvent<HTMLInputElement>) =>
    setAddColorVal(e.target.value as string);

  const ToastColorOptions = (color: string): Pick<ToastOptions, "iconTheme" | "style"> => {
    return {
      iconTheme: { primary: color, secondary: getFontColor(color) },
      style: { borderColor: color },
    };
  };

  const handleAddColor = () => {
    if (colorList.length >= MAX_COLORS_IN_LIST) {
      showToast(`You cannot add more than ${MAX_COLORS_IN_LIST} colors to color list.`, {
        type: "error",
      });
      return;
    }

    if (
      colorList.some((color) => color.toLowerCase() === addColorVal.toLowerCase()) ||
      addColorVal.toLowerCase() === theme.primary.toLowerCase()
    ) {
      showToast("Color is already in color list.", { type: "error" });
      return;
    }

    handleColorChange(addColorVal.toUpperCase());
    setUser({ ...user, colorList: [...colorList, addColorVal.toUpperCase()] });
    showToast(
      <div>
        Added{" "}
        <b>
          <ToastColorPreview clr={addColorVal} />
          {getColorName(addColorVal).name}
        </b>{" "}
        to your color list.
      </div>,
      ToastColorOptions(addColorVal)
    );
    handleAddDialogClose();
  };

  const handleDeleteColor = (clr: string) => {
    setPopoverOpen(Array(colorList.length).fill(false));
    showToast(
      <div>
        Removed{" "}
        <b>
          <ToastColorPreview clr={clr} />
          {getColorName(clr).name}
        </b>{" "}
        from your color list.
      </div>,
      ToastColorOptions(clr)
    );

    setUser({
      ...user,
      colorList: colorList.filter((listColor) => listColor !== clr),
    });
  };

  return (
    <>
      <StyledAccordion
        onChange={handleAccordionChange}
        sx={{
          width: width,
        }}
      >
        <AccordionSummary
          expandIcon={<ExpandMoreRounded sx={{ color: fontColor || ColorPalette.fontLight }} />}
          sx={{ fontWeight: 500 }}
        >
          <div style={{ display: "flex", alignItems: "center", gap: "12px" }}>
            {!accordionExpanded && <AccordionPreview clr={selectedColor} />}
            <span style={{ color: fontColor || ColorPalette.fontLight }}>
              {label || "Color"}
              {!accordionExpanded && ` - ${getColorName(selectedColor).name}`}
            </span>
          </div>
        </AccordionSummary>
        <AccordionDetails>
          <ColorPreview maxWidth={width || 400} clr={selectedColor}>
            {selectedColor.toUpperCase()} - {getColorName(selectedColor).name}
          </ColorPreview>
          <div
            style={{
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              maxWidth: width || 400,
            }}
          >
            <Grid container spacing={1} maxWidth={width || 400} m={1}>
              {[theme.primary, ...colorList].map((color, index) => (
                <Grid item key={color}>
                  <Tooltip title={getColorName(color).name}>
                    <ColorElement
                      ref={(element) => (colorElementRefs.current[index] = element)}
                      id={`color-element-${index}`}
                      clr={color}
                      aria-label={`Select color - ${color}`}
                      // show delete popover only on desktop
                      onContextMenu={(e) => {
                        if (
                          window.matchMedia("(pointer:fine)").matches &&
                          color !== theme.primary
                        ) {
                          e.preventDefault();
                          togglePopover(index);
                        }
                      }}
                      onClick={() => {
                        handleColorChange(color);
                        // show delete popover on mobile only after double tap
                        if (!window.matchMedia("(pointer:fine)").matches) {
                          if (selectedColor === color && color !== theme.primary) {
                            togglePopover(index);
                          }
                        }
                      }}
                    >
                      {color.toUpperCase() === selectedColor.toUpperCase() && <SelectedIcon />}
                    </ColorElement>
                  </Tooltip>
                  <Popover
                    open={popoverOpen[index] === true}
                    onClose={() => togglePopover(index)}
                    anchorEl={colorElementRefs.current[index]}
                    anchorOrigin={{
                      vertical: "top",
                      horizontal: "center",
                    }}
                    transformOrigin={{
                      vertical: "top",
                      horizontal: "center",
                    }}
                    slotProps={{
                      paper: {
                        sx: {
                          background: "transparent",
                          boxShadow: "none",
                        },
                      },
                    }}
                  >
                    <div>
                      <DeleteColorBtn onClick={() => handleDeleteColor(color)}>
                        Delete
                      </DeleteColorBtn>
                    </div>
                  </Popover>
                </Grid>
              ))}
              <Tooltip title="Add new color">
                <Grid item>
                  <ColorElement
                    clr="transparent"
                    style={{ border: "2px solid", color: fontColor || ColorPalette.fontLight }}
                    onClick={handleAddDialogOpen}
                  >
                    <AddRounded style={{ fontSize: "38px" }} />
                  </ColorElement>
                </Grid>
              </Tooltip>
            </Grid>
          </div>
          <StyledInfo clr={fontColor || ColorPalette.fontLight}>
            <InfoRounded fontSize="small" />{" "}
            {window.matchMedia("(pointer:fine)").matches ? "Right click" : "Double tap"} to remove
            color from list
          </StyledInfo>
        </AccordionDetails>
      </StyledAccordion>
      <Dialog open={openAddDialog} onClose={handleAddDialogClose}>
        <DialogTitle>Add new color</DialogTitle>
        <DialogContent>
          <div
            style={{
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              margin: "4px 0",
              fontWeight: 600,
            }}
          >
            {addColorVal.toUpperCase()} - {getColorName(addColorVal).name}
          </div>
          <div style={{ position: "relative" }}>
            <StyledColorPicker
              type="color"
              // list={systemInfo.os === "iOS" ? "color-list" : undefined}
              value={addColorVal}
              onChange={handlePickerChange}
            />
            {/* <datalist id="color-list">
              <option value={theme.primary} />
              {colorList.map((color) => (
                <option value={color} key={color} />
              ))}
            </datalist> */}
            <PickerLabel clr={getFontColor(addColorVal)}>
              <ColorizeRounded /> Choose color
            </PickerLabel>
          </div>
        </DialogContent>
        <DialogActions>
          <DialogBtn onClick={handleAddDialogClose}>Cancel</DialogBtn>
          <DialogBtn
            onClick={() => {
              onColorChange(addColorVal);
              handleAddDialogClose();
            }}
          >
            <ColorizeRounded /> &nbsp; Set
          </DialogBtn>
          <DialogBtn onClick={handleAddColor}>
            <AddRounded /> &nbsp; Add
          </DialogBtn>
        </DialogActions>
      </Dialog>
    </>
  );
};

const StyledAccordion = styled(Accordion)`
  background: #ffffff18;
  border-radius: 16px !important;
  border: 1px solid #0000003a;
  box-shadow: none;
  padding: 6px 0;
  margin: 8px 0;
`;

const AccordionPreview = styled.div<{ clr: string }>`
  width: 24px;
  height: 24px;
  background: ${({ clr }) => clr};
  border-radius: 8px;
  transition: 0.3s background;
`;

const ToastColorPreview = styled(AccordionPreview)`
  width: 18px;
  height: 18px;
  border-radius: 6px;
  display: inline-block;
  margin-right: 5px;
  margin-left: 2px;
  vertical-align: middle;
`;

const ColorPreview = styled(Grid)<{ clr: string }>`
  margin-top: 16px;
  display: flex;
  justify-content: center;
  align-items: center;
  background: ${({ clr }) => clr};
  color: ${({ clr }) => getFontColor(clr)};
  padding: 8px;
  border-radius: 100px;
  transition: 0.3s all;
  font-weight: 600;
  border: 2px solid #ffffffab;
`;

const DeleteColorBtn = styled.button`
  border: none;
  outline: none;
  background-color: #141431dd;
  color: #ff4e4e;
  font-weight: 500;
  padding: 4px 8px;
  cursor: pointer;
  border-radius: 10px;
  backdrop-filter: blur(6px);
  @media (max-width: 768px) {
    padding: 6px 10px;
    font-size: 15px;
  }
`;

const StyledInfo = styled.span<{ clr: string }>`
  color: ${({ clr }) => clr};
  opacity: 0.8;
  display: flex;
  align-items: center;
  gap: 4px;
  margin-top: 8px;
  margin-left: 4px;
  font-size: 14px;
`;

const PickerLabel = styled.p<{ clr: string }>`
  position: absolute;
  display: flex;
  align-items: center;
  gap: 8px;
  color: ${({ clr }) => clr};
  pointer-events: none;
  top: 0;
  left: 50%;
  transform: translate(-50%, 0%);
  font-weight: 600;
`;

const SelectedIcon = styled(DoneRounded)`
  font-size: 28px;
  animation: ${scale} 0.25s;
`;

const StyledColorPicker = styled.input`
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  height: 54px;
  width: 100%;
  display: flex;

  background-color: transparent;
  border: none;
  cursor: pointer;

  &::-webkit-color-swatch {
    border-radius: 18px;
    border: none;
  }
  &::-moz-color-swatch {
    border-radius: 18px;
    border: none;
  }
`;


// File: workspace/TodoApp/src/components/CategorySelect.tsx
import styled from "@emotion/styled";
import { ExpandMoreRounded, RadioButtonChecked } from "@mui/icons-material";
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  MenuItem,
  Select,
  SelectChangeEvent,
} from "@mui/material";
import { Emoji } from "emoji-picker-react";
import { CSSProperties, useContext, useState } from "react";
import { useNavigate } from "react-router-dom";
import { CategoryBadge } from ".";
import { MAX_CATEGORIES_IN_TASK } from "../constants";
import { UserContext } from "../contexts/UserContext";
import type { Category, UUID } from "../types/user";
import { getFontColor, showToast } from "../utils";
import { ColorPalette } from "../theme/themeConfig";

interface CategorySelectProps {
  selectedCategories: Category[];
  onCategoryChange?: (categories: Category[]) => void;
  width?: CSSProperties["width"];
  fontColor?: CSSProperties["color"];
}

/**
 * Component for selecting categories with emojis.
 */
export const CategorySelect: React.FC<CategorySelectProps> = ({
  selectedCategories,
  onCategoryChange,
  width,
  fontColor,
}) => {
  const { user } = useContext(UserContext);
  const { categories, emojisStyle } = user;
  const [selectedCats, setSelectedCats] = useState<Category[]>(selectedCategories);
  const [isOpen, setIsOpen] = useState<boolean>(false);

  const n = useNavigate();

  const handleCategoryChange = (event: SelectChangeEvent<unknown>): void => {
    const selectedCategoryIds = event.target.value as UUID[];
    if (selectedCategoryIds.length > MAX_CATEGORIES_IN_TASK) {
      showToast(`You cannot add more than ${MAX_CATEGORIES_IN_TASK} categories`, {
        type: "error",
        position: "top-center",
      });

      return;
    }
    const selectedCategories = categories.filter((cat) => selectedCategoryIds.includes(cat.id));
    setSelectedCats(selectedCategories);
    onCategoryChange && onCategoryChange(selectedCategories);
  };

  return (
    <FormControl sx={{ width: width || "100%" }}>
      <FormLabel
        sx={{
          color: fontColor ? `${fontColor}e8` : `${ColorPalette.fontLight}e8`,
          marginLeft: "8px",
          fontWeight: 500,
        }}
      >
        Category
      </FormLabel>
      <StyledSelect
        multiple
        width={width}
        value={selectedCats.map((cat) => cat.id)}
        onChange={handleCategoryChange}
        open={isOpen}
        onOpen={() => setIsOpen(true)}
        onClose={() => setIsOpen(false)}
        IconComponent={() => (
          <Box
            sx={{ display: "flex", alignItems: "center", cursor: "pointer" }}
            onClick={() => setIsOpen((prev) => !prev)}
          >
            <ExpandMoreRounded
              sx={{
                marginRight: "14px",
                color: fontColor || ColorPalette.fontLight,
                transform: isOpen ? "rotate(180deg)" : "none",
              }}
            />
          </Box>
        )}
        renderValue={() => (
          <Box sx={{ display: "flex", flexWrap: "wrap", gap: "4px 8px" }}>
            {selectedCats.map((category) => (
              <CategoryBadge
                key={category.id}
                category={category}
                sx={{ cursor: "pointer" }}
                glow={false}
              />
            ))}
          </Box>
        )}
        MenuProps={{
          PaperProps: {
            style: {
              maxHeight: 450,
              zIndex: 999999,
              padding: "0px 8px",
            },
          },
        }}
      >
        <HeaderMenuItem disabled>
          <div style={{ display: "flex", flexDirection: "column", gap: "2px" }}>
            <b>
              Select Categories{" "}
              <span
                style={{
                  transition: ".3s color",
                  color: selectedCats.length >= MAX_CATEGORIES_IN_TASK ? "#f34141" : "currentcolor",
                }}
              >
                {categories.length > 3 && <span>(max {MAX_CATEGORIES_IN_TASK})</span>}
              </span>
            </b>
            {selectedCats.length > 0 && (
              <SelectedNames>
                Selected{" "}
                {selectedCats.length > 0 &&
                  new Intl.ListFormat("en", {
                    style: "long",
                    type: "conjunction",
                  }).format(selectedCats.map((category) => category.name))}
              </SelectedNames>
            )}
          </div>
        </HeaderMenuItem>

        {categories && categories.length > 0 ? (
          categories.map((category) => (
            <CategoriesMenu
              key={category.id}
              value={category.id}
              clr={category.color}
              translate="no"
              disable={
                selectedCats.length >= MAX_CATEGORIES_IN_TASK &&
                !selectedCats.some((cat) => cat.id === category.id)
              }
            >
              {selectedCats.some((cat) => cat.id === category.id) && <RadioButtonChecked />}
              {category.emoji && <Emoji unified={category.emoji} emojiStyle={emojisStyle} />}
              &nbsp;
              {category.name}
            </CategoriesMenu>
          ))
        ) : (
          <NoCategories disableTouchRipple>
            <p>You don't have any categories</p>
            <Button
              fullWidth
              variant="outlined"
              onClick={() => {
                n("/categories");
              }}
            >
              Add Category
            </Button>
          </NoCategories>
        )}
      </StyledSelect>
    </FormControl>
  );
};

const StyledSelect = styled(Select)<{ width?: CSSProperties["width"] }>`
  margin: 12px 0;
  border-radius: 16px !important;
  transition: 0.3s all;
  width: ${({ width }) => width || "100%"};
  color: white;
  background: #ffffff18;
  z-index: 999;
`;

const CategoriesMenu = styled(MenuItem)<{ clr: string; disable?: boolean }>`
  padding: 12px 16px;
  border-radius: 16px;
  margin: 8px;
  display: flex;
  gap: 4px;
  font-weight: 600;
  transition: 0.2s all;
  color: ${(props) => getFontColor(props.clr || ColorPalette.fontLight)};
  background: ${({ clr }) => clr};
  opacity: ${({ disable }) => (disable ? ".6" : "none")};
  &:hover {
    background: ${({ clr }) => clr};
    opacity: ${({ disable }) => (disable ? "none" : ".8")};
  }

  &:focus {
    opacity: none;
  }

  &:focus-visible {
    border-color: ${({ theme }) => theme.primary} !important;
  }

  &.Mui-selected {
    background: ${({ clr }) => clr};
    color: ${(props) => getFontColor(props.clr || ColorPalette.fontLight)};
    display: flex;
    justify-content: left;
    align-items: center;
    font-weight: 800;
    &:hover {
      background: ${({ clr }) => clr};
      opacity: 0.7;
    }
  }
`;

const HeaderMenuItem = styled(MenuItem)`
  opacity: 1 !important;
  font-weight: 500;
  position: sticky !important;
  top: 0;
  backdrop-filter: blur(6px);
  z-index: 99;
  pointer-events: none;
  background: ${({ theme }) => (theme.darkmode ? "#2f2f2fc3" : "#ffffffc3")};
`;

const SelectedNames = styled.span`
  opacity: 0.9;
  font-size: 15px;
  word-break: break-all;
  max-width: 300px;
`;

const NoCategories = styled(MenuItem)`
  opacity: 1 !important;
  font-size: 16px;
  font-weight: 600;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  margin: 12px 0;
  gap: 6px;
  cursor: default !important;
  & p {
    margin: 20px 0 32px 0;
  }
  &:hover {
    background: transparent !important;
  }
`;


// File: workspace/TodoApp/src/components/ErrorBoundary.tsx
import styled from "@emotion/styled";
import {
  DataObjectRounded,
  DeleteForeverRounded,
  DescriptionRounded,
  ErrorOutlineRounded,
  ExpandMoreRounded,
  FileDownload,
  RefreshRounded,
} from "@mui/icons-material";
import {
  Accordion,
  AccordionDetails,
  AccordionSummary,
  Alert,
  Button,
  Typography,
} from "@mui/material";
import { Emoji } from "emoji-picker-react";
import React, { ErrorInfo } from "react";
import { TaskIcon } from ".";
import { UserContext } from "../contexts/UserContext";
import { StyledLink } from "../styles";
import { exportTasksToJson, getFontColor, showToast } from "../utils";

interface ErrorBoundaryProps {
  children: React.ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

/**
 * ErrorBoundary component that catches and displays errors.
 */

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  static contextType = UserContext;
  declare context: React.ContextType<typeof UserContext>;
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
    };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return {
      hasError: true,
      error: error,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error("Error:", error);
    console.error("Error Info:", errorInfo);
  }

  handleClearData() {
    localStorage.clear();
    sessionStorage.clear();
    location.reload();
  }

  render() {
    if (this.state.hasError) {
      const { user } = this.context;
      const { tasks } = user;

      return (
        <Container>
          <ErrorHeader>
            <span>Oops! An error occurred.&nbsp;</span>
            <span>
              <Emoji size={38} unified="1f644" />
            </span>
          </ErrorHeader>
          <ErrorIconContainer>
            <TaskIcon scale={0.6} variant="error" />
          </ErrorIconContainer>
          <h2>
            To fix it, try clearing your local files (cookies and cache) and then refresh the page.
            If the problem persists, please report the issue via{" "}
            <StyledLink translate="no" href="https://github.com/maciekt07/TodoApp/issues">
              Github Issues
            </StyledLink>
            .
          </h2>
          <Alert severity="error" variant="filled" sx={{ mt: "-8px", mb: "18px" }}>
            By cleaning app data, you will lose all of your tasks.
          </Alert>
          <div style={{ display: "flex", gap: "12px" }}>
            <StyledButton color="warning" onClick={() => location.reload()}>
              <RefreshRounded /> &nbsp; Refresh Page
            </StyledButton>
            <StyledButton color="error" onClick={this.handleClearData}>
              <DeleteForeverRounded /> &nbsp; Auto Clear
            </StyledButton>
          </div>
          <h3>
            <span style={{ color: "#ff3131", display: "inline-block" }}>
              <ErrorOutlineRounded sx={{ verticalAlign: "middle", mb: "4px" }} /> ERROR:
            </span>{" "}
            <span translate="no">
              [{this.state.error?.name}] {this.state.error?.message}
            </span>
          </h3>

          <ErrorAccordion disableGutters>
            <AccordionSummary expandIcon={<ErrorExpandIcon />}>
              <Typography
                fontWeight={700}
                fontSize={18}
                sx={{ display: "flex", alignItems: "center", gap: "6px" }}
              >
                <DescriptionRounded /> Error stack
              </Typography>
            </AccordionSummary>
            <AccordionDetails>
              <div translate="no" style={{ opacity: 0.8, fontSize: "12px" }}>
                {this.state.error?.stack?.replace(this.state.error?.message, "")}
              </div>
            </AccordionDetails>
          </ErrorAccordion>

          <pre>
            <UserDataLabel>
              <DataObjectRounded /> &nbsp; User Data
            </UserDataLabel>
            <Button
              variant="outlined"
              sx={{ ml: "6px", my: "18px", p: "12px 20px", borderRadius: "14px" }}
              onClick={() => {
                exportTasksToJson(tasks);
                showToast(`Exported all tasks (${tasks.length})`);
              }}
            >
              <FileDownload /> &nbsp; Export Tasks To JSON
            </Button>
            <br />
            <code translate="no">{JSON.stringify(user, null, 4)}</code>
          </pre>
        </Container>
      );
    }

    return this.props.children;
  }
}

const Container = styled.div`
  margin: 0 8vw;
  @media (max-width: 768px) {
    margin: 0;
  }
`;

const ErrorIconContainer = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 8px;
`;

const ErrorHeader = styled.h1`
  margin-top: 32px;
  margin-bottom: 32px;
  font-size: 36px;
  color: #ff3131;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  @media (max-width: 768px) {
    text-align: left;
    justify-content: left;
    font-size: 30px;
    margin-top: 0;
    margin-bottom: 0;
  }
`;

const ErrorAccordion = styled(Accordion)`
  color: ${({ theme }) => getFontColor(theme.secondary)};
  border-radius: 14px !important;
  background: ${({ theme }) => getFontColor(theme.secondary)}18;
  box-shadow: none;
  padding: 4px;
  margin-bottom: 18px;
`;

const ErrorExpandIcon = styled(ExpandMoreRounded)`
  color: ${({ theme }) => getFontColor(theme.secondary)};
  font-size: 32px;
`;

const StyledButton = styled(Button)`
  padding: 10px 30px;
  border-radius: 12px;
  @media (max-width: 768px) {
    width: 100%;
  }
`;
StyledButton.defaultProps = {
  variant: "outlined",
  size: "large",
};

const UserDataLabel = styled.p`
  font-size: 18px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 8px 0;
`;

export default ErrorBoundary;


// File: workspace/TodoApp/src/components/tasks/tasks.styled.tsx
import styled from "@emotion/styled";
import { Alarm, RadioButtonChecked, RadioButtonUnchecked } from "@mui/icons-material";
import { Button, Checkbox, IconButton, TextField, css } from "@mui/material";
import { fadeIn, ring, scale } from "../../styles/keyframes.styled";
import { getFontColor, systemInfo } from "../../utils";
import { ColorPalette } from "../../theme/themeConfig";

interface TaskComponentProps {
  backgroundColor: string;
  done: boolean;
  glow?: boolean;
  blur?: boolean;
}

export const TaskContainer = styled.div<TaskComponentProps>`
  display: flex;
  align-items: center;
  margin-top: 14px;
  transition: 0.3s all !important;
  background-color: ${({ backgroundColor, done }) => `${backgroundColor}${done ? "cc" : ""}`};
  opacity: ${({ done }) => (done ? 0.8 : 1)};
  color: ${({ backgroundColor }) => getFontColor(backgroundColor)};
  border-left: ${({ done }) => (done ? "8px solid #00ff1ee3" : "1px solid transparent")};
  box-shadow: ${(props) =>
    props.glow && !props.blur ? `0 0 128px -20px ${props.backgroundColor}` : "none"};
  padding: 16px 16px 16px 20px;
  border-radius: 28px;
  animation: ${fadeIn} 0.5s ease-in;
  filter: ${({ blur }) => (blur ? "blur(2px) opacity(75%)" : "none")};
  text-shadow: ${({ backgroundColor, glow, done }) =>
    glow && !done ? `0 0 4px ${getFontColor(backgroundColor)}78` : "none"};
  /* If the theme color and task color are the same, it changes the selection color to be different. */
  *::selection {
    background-color: ${({ theme, backgroundColor }) =>
      theme.primary === backgroundColor ? "#ffffff" : theme.primary} !important;
    color: ${({ theme, backgroundColor }) =>
      theme.primary === backgroundColor ? "#000000" : getFontColor(theme.primary)} !important;
  }
  @media (max-width: 768px) {
    padding: 14px 14px 14px 18px;
    margin-top: 12px;
  }
`;

TaskContainer.defaultProps = {
  className: "TaskContainer",
};

export const EmojiContainer = styled.span<{ clr: string }>`
  text-decoration: none;
  margin-right: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: ${({ clr }) => (clr === ColorPalette.fontDark ? "#4b4b4b6e" : "#dddddd9d")};
  font-size: 32px;
  padding: 14px;
  width: 42px;
  height: 42px;
  border-radius: 18px;
  overflow: hidden;
  text-overflow: ellipsis;
`;

export const TaskInfo = styled.div`
  display: flex;
  flex-direction: column;
  flex: 1;
`;

export const TaskHeader = styled.div`
  display: flex;
  align-items: center;
`;

export const TaskName = styled.h3<{ done: boolean }>`
  font-size: 20px;
  margin: 0;
  text-decoration: ${({ done }) => (done ? "line-through" : "none")};
  word-break: break-word;
  white-space: pre-line;
`;

export const TaskDate = styled.p`
  margin: 0 6px;
  text-align: right;
  margin-left: auto;
  font-size: 14px;
  font-style: italic;
  font-weight: 300;
  backdrop-filter: none !important;
`;

export const TaskDescription = styled.p<{ done: boolean }>`
  margin: 0;
  font-size: 18px;
  text-decoration: ${({ done }) => (done ? "line-through" : "none")};
  word-break: break-word;
`;

export const ShowMoreBtn = styled(Button)<{ clr: string }>`
  background: none;
  border: none;
  cursor: pointer;
  font-size: 16px;
  font-weight: bolder;
  transition: 0.3s color;
  color: ${({ clr }) => getFontColor(clr)};
  text-shadow: ${({ clr }) => `0 0 8px ${getFontColor(clr) + 45}`};
  text-transform: capitalize;
  border-radius: 6px;
  padding: 0 4px;
  margin: 0 4px;
`;

export const NoTasks = styled.div`
  text-align: center;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  min-width: 100vw;
  opacity: 0.9;
  font-size: 18px;
`;

export const TasksContainer = styled.main`
  display: flex;
  justify-content: center;
  max-width: 700px;
  margin: 0 auto;
  flex-direction: column;
  gap: 6px;
`;

export const TimeLeft = styled.span<{ done: boolean }>`
  text-decoration: ${({ done }) => (done ? "line-through" : "none")};
  transition: 0.3s all;
  font-size: 14px;
  margin: 4px 0;
  font-weight: 500;
  font-style: italic;
  display: flex;
  backdrop-filter: none !important;
  // fix for browser translate
  & font {
    margin: 0 1px;
  }
`;

export const Pinned = styled.div`
  display: flex;
  justify-content: left;
  align-items: center;
  opacity: 0.8;
  font-size: 16px;
`;

export const SelectedTasksContainer = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin: 8px 0;
  background: ${({ theme }) =>
    getFontColor(theme.secondary) === ColorPalette.fontLight ? "#090b2287" : "#ffffff5c"};
  padding: 16px 20px;
  border-radius: 18px;
  position: sticky;
  top: ${systemInfo.os === "iOS" ? "52" : "60"}px;
  z-index: 1;
  backdrop-filter: blur(24px);
  & h3 {
    margin: 0;
    display: flex;
    align-items: center;
  }
  & font {
    margin: 0 1px;
  }
`;

export const StyledRadio = styled(Checkbox)<{ clr: string }>`
  margin-left: -8px;
  margin-right: 4px;
  color: ${({ clr }) => clr} !important;
  animation: ${fadeIn} 0.3s ease-in;
  &.Mui-checked {
    color: ${({ clr }) => clr} !important;
  }
`;

const radioIconStyles = css`
  animation: ${scale} 0.2s ease-in;
  font-size: 24px;
  @media (max-width: 768px) {
    font-size: 26px;
  }
`;

export const RadioChecked = styled(RadioButtonChecked)`
  ${radioIconStyles}
`;

export const RadioUnchecked = styled(RadioButtonUnchecked)`
  ${radioIconStyles}
`;

export const CategoriesListContainer = styled.div`
  position: sticky;
  background: transparent;
  backdrop-filter: blur(24px);
  z-index: 2;
  top: 0;
  display: flex;
  justify-content: left;
  align-items: left;
  gap: 8px;
  overflow-x: auto;
  padding: 0 0 6px 0;
  margin: 8px 0;

  /* Custom Scrollbar Styles */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
    border-radius: 4px;
    background-color: ${({ theme }) => getFontColor(theme.secondary)}15;
  }

  ::-webkit-scrollbar-thumb {
    background-color: ${({ theme }) => getFontColor(theme.secondary)}30;
    border-radius: 4px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background-color: ${({ theme }) => getFontColor(theme.secondary)}50;
  }

  ::-webkit-scrollbar-track {
    border-radius: 4px;
    background-color: ${({ theme }) => getFontColor(theme.secondary)}15;
  }
`;

export const HighlightedText = styled.span`
  background-color: #6829ef;
  color: #fff;
  padding: 2px 0;
  border-radius: 4px;
  box-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
  margin: 0;
  font-weight: bold;
  border: 1px solid #ffffff5f;
  transition: 0.3s all;
`;

export const DescriptionLink = styled(Button)<{ clr: string }>`
  margin: 0;
  color: ${({ clr }) => getFontColor(clr)};
  padding: 0 4px;
  display: inline-block;
  background: ${({ clr }) => getFontColor(clr)}28;
  backdrop-filter: none !important;
  text-transform: none !important;
  min-width: unset !important;
  user-select: auto !important;
  border-radius: 6px;
  &:hover {
    background: ${({ clr }) => getFontColor(clr)}19;
  }
  & div {
    word-break: break-all;
    display: flex;
    align-items: center;
    gap: 4px;
  }
`;

export const YouTubeThumbnail = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 6px;
  & img {
    width: 300px;
    height: 160px;
    border-radius: 12px;
    margin-bottom: 6px;
    object-fit: cover;
    object-position: 100%;
    opacity: 0.9;
  }
  @media (max-width: 768px) {
    & img {
      width: 150px;
      height: 80px;
    }
    justify-content: left;
  }
`;

export const SearchInput = styled(TextField)`
  margin: 8px 0 0 0;
  border-radius: 16px;
  transition: 0.3s all;
  width: 100%;
  & .MuiOutlinedInput-notchedOutline {
    border: 1px solid
      ${({ theme }) =>
        getFontColor(theme.secondary) === ColorPalette.fontLight
          ? "#44479cb7"
          : theme.primary} !important;
  }
  & .MuiOutlinedInput-root {
    padding: 2px 16px;
    border-radius: 16px;
    transition: 0.3s all;
    background: ${({ theme }) =>
      getFontColor(theme.secondary) === ColorPalette.fontLight ? "#090b2258" : "#ffffff3e"};
    color: ${({ theme }) => getFontColor(theme.secondary)};
    & .MuiSvgIcon-root {
      color: ${({ theme }) => getFontColor(theme.secondary)};
    }
  }
`;

export const SearchClear = styled(IconButton)`
  animation: ${scale} 0.3s ease;
  transition: 0.3s all;
`;

const ringAnimation = "2s 0.5s ease-in-out infinite";

export const RingAlarm = styled(Alarm)<{ animate?: boolean }>`
  color: red;
  ${({ animate }) =>
    animate &&
    css`
      -webkit-animation: ${ring} ${ringAnimation};
      -moz-animation: ${ring} ${ringAnimation};
      animation: ${ring} ${ringAnimation};
    `}
`;


// File: workspace/TodoApp/src/components/tasks/RenderTaskDescription.tsx
import {
  GitHub,
  ImageRounded,
  Language,
  Link,
  LinkedIn,
  Reddit,
  X,
  YouTube,
} from "@mui/icons-material";
import { Tooltip } from "@mui/material";
import { memo, useContext } from "react";
import { DESCRIPTION_SHORT_LENGTH, URL_REGEX } from "../../constants";
import { useResponsiveDisplay } from "../../hooks/useResponsiveDisplay";
import { Task } from "../../types/user";
import { DescriptionLink, ShowMoreBtn, YouTubeThumbnail } from "./tasks.styled";
import { TaskContext } from "../../contexts/TaskContext";

interface RenderTaskDescriptionProps {
  task: Task;
}

/**
 * Function to render task description with links
 */
export const RenderTaskDescription = memo(
  ({ task }: RenderTaskDescriptionProps): JSX.Element | null => {
    const { expandedTasks, toggleShowMore, highlightMatchingText } = useContext(TaskContext);
    const isMobile = useResponsiveDisplay();

    if (!task || !task.description) {
      return null;
    }

    const { description, color, id } = task;

    const hasLinks = description.match(URL_REGEX);

    const isExpanded = expandedTasks.has(id);
    const highlightedDescription =
      isExpanded || hasLinks ? description : description.slice(0, DESCRIPTION_SHORT_LENGTH);

    const parts = highlightedDescription.split(URL_REGEX);

    interface DomainMappings {
      regex: RegExp;
      domainName?: string;
      icon: JSX.Element;
    }

    const domainMappings: DomainMappings[] = [
      { regex: /(m\.)?youtu(\.be|be\.com)/, domainName: "Youtube", icon: <YouTube /> },
      {
        regex: /(twitter\.com|x\.com)/,
        domainName: "X",
        icon: <X sx={{ fontSize: "18px" }} />,
      },
      { regex: /github\.com/, domainName: "Github", icon: <GitHub sx={{ fontSize: "20px" }} /> },
      { regex: /reddit\.com/, domainName: "Reddit", icon: <Reddit /> },
      { regex: /linkedin\.com/, domainName: "LinkedIn", icon: <LinkedIn /> },
      { regex: /localhost/, icon: <Language /> },
      { regex: /.*/, icon: <Link /> }, // Default icon for other domains
    ];

    const descriptionWithLinks = parts.map((part, index) => {
      if (index % 2 === 0) {
        return highlightMatchingText(part);
      } else {
        let domain: string = "";
        let icon: JSX.Element = <Link />;

        try {
          const url = new URL(part);
          domain = url.hostname.replace("www.", "");
          // Find the matching icon for the domain
          const mapping = domainMappings.find(({ regex }) => domain.match(regex));
          icon = mapping ? mapping.icon : <Link />; // Default to Link icon
          domain =
            mapping && mapping.domainName ? mapping.domainName : url.hostname.replace("www.", "");
        } catch (error) {
          // If URL construction fails
          console.error("Invalid URL:", part);
        }

        // Check if part matches any image file extensions
        if (part.match(/\.(jpeg|jpg|gif|png|bmp|svg|tif|tiff|webp)$/)) {
          icon = <ImageRounded />;
        }

        const youtubeId = (youtubeLink: string) =>
          youtubeLink.match(
            /(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))([^&?]+)/
          )?.[1] || null;

        return (
          <Tooltip
            title={
              <>
                <span style={{ wordBreak: "break-all" }}>{part}</span>
                {part.match(domainMappings[0].regex) && youtubeId(part) && !isMobile && (
                  <YouTubeThumbnail>
                    <img
                      src={`https://i.ytimg.com/vi/${youtubeId(part)}/hqdefault.jpg`}
                      alt="YouTube Thumbnail"
                      loading="lazy"
                    />
                  </YouTubeThumbnail>
                )}
              </>
            }
            key={index}
          >
            <DescriptionLink
              role="link"
              data-href={part}
              clr={color}
              onClick={() => window.open(part)}
            >
              <div>
                {icon} {highlightMatchingText(domain)}
              </div>
            </DescriptionLink>
          </Tooltip>
        );
      }
    });

    return (
      <div>
        {descriptionWithLinks}{" "}
        {task.description && task.description.length > DESCRIPTION_SHORT_LENGTH && !hasLinks && (
          <ShowMoreBtn onClick={() => toggleShowMore(task.id)} clr={task.color}>
            {expandedTasks.has(task.id) ? "Show less" : "Show more"}
          </ShowMoreBtn>
        )}
      </div>
    );
  }
);


// File: workspace/TodoApp/src/components/tasks/TasksList.tsx
import { useTheme } from "@emotion/react";
import {
  CancelRounded,
  Close,
  Delete,
  DeleteRounded,
  DoneAll,
  DoneRounded,
  Link,
  MoreVert,
  PushPinRounded,
  RadioButtonChecked,
  Search,
} from "@mui/icons-material";
import {
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  IconButton,
  InputAdornment,
  Tooltip,
} from "@mui/material";
import { Emoji, EmojiStyle } from "emoji-picker-react";
import { useCallback, useContext, useEffect, useMemo, useState } from "react";
import { CategoryBadge, EditTask, TaskIcon, TaskMenu } from "..";
import { URL_REGEX } from "../../constants";
import { TaskContext } from "../../contexts/TaskContext";
import { UserContext } from "../../contexts/UserContext";
import { useCtrlS } from "../../hooks/useCtrlS";
import { useResponsiveDisplay } from "../../hooks/useResponsiveDisplay";
import { useStorageState } from "../../hooks/useStorageState";
import { DialogBtn } from "../../styles";
import { ColorPalette } from "../../theme/themeConfig";
import type { Category, Task, UUID } from "../../types/user";
import {
  calculateDateDifference,
  formatDate,
  getFontColor,
  showToast,
  systemInfo,
} from "../../utils";
import { RenderTaskDescription } from "./RenderTaskDescription";
import {
  CategoriesListContainer,
  EmojiContainer,
  NoTasks,
  Pinned,
  RadioChecked,
  RadioUnchecked,
  RingAlarm,
  SearchClear,
  SearchInput,
  SelectedTasksContainer,
  StyledRadio,
  TaskContainer,
  TaskDate,
  TaskDescription,
  TaskHeader,
  TaskInfo,
  TaskName,
  TasksContainer,
  TimeLeft,
} from "./tasks.styled";

/**
 * Component to display a list of tasks.
 */

export const TasksList: React.FC = () => {
  const { user, setUser } = useContext(UserContext);
  const {
    selectedTaskId,
    setSelectedTaskId,
    anchorEl,
    setAnchorEl,
    setAnchorPosition,
    expandedTasks,
    toggleShowMore,
    search,
    setSearch,
    highlightMatchingText,
    multipleSelectedTasks,
    setMultipleSelectedTasks,
    handleSelectTask,
    editModalOpen,
    setEditModalOpen,
    deleteDialogOpen,
    setDeleteDialogOpen,
  } = useContext(TaskContext);
  const open = Boolean(anchorEl);

  const [deleteSelectedOpen, setDeleteSelectedOpen] = useState<boolean>(false);
  const [categories, setCategories] = useState<Category[] | undefined>(undefined);
  const [selectedCatId, setSelectedCatId] = useStorageState<UUID | undefined>(
    undefined,
    "selectedCategory",
    "sessionStorage"
  );
  const [categoryCounts, setCategoryCounts] = useState<{
    [categoryId: UUID]: number;
  }>({});
  const isMobile = useResponsiveDisplay();
  const theme = useTheme();
  useCtrlS();

  const listFormat = useMemo(
    () =>
      new Intl.ListFormat("en-US", {
        style: "long",
        type: "conjunction",
      }),
    []
  );

  const selectedTask = useMemo(() => {
    return user.tasks.find((task) => task.id === selectedTaskId) || ({} as Task);
  }, [user.tasks, selectedTaskId]);

  // Handler for clicking the more options button in a task
  const handleClick = (event: React.MouseEvent<HTMLElement>, taskId: UUID) => {
    setAnchorEl(event.currentTarget);
    setSelectedTaskId(taskId);
    const target = event.target as HTMLElement;
    // Position the menu where the click event occurred
    if (target.tagName !== "BUTTON") {
      setAnchorPosition({
        top: event.clientY,
        left: event.clientX,
      });
    } else {
      setAnchorPosition(null);
    }
    if (!isMobile && !expandedTasks.has(taskId)) {
      toggleShowMore(taskId);
    }
  };

  const reorderTasks = useCallback(
    (tasks: Task[]): Task[] => {
      // Separate tasks into pinned and unpinned
      let pinnedTasks = tasks.filter((task) => task.pinned);
      let unpinnedTasks = tasks.filter((task) => !task.pinned);

      // Filter tasks based on the selected category
      if (selectedCatId !== undefined) {
        const categoryFilter = (task: Task) =>
          task.category?.some((category) => category.id === selectedCatId) ?? false;
        unpinnedTasks = unpinnedTasks.filter(categoryFilter);
        pinnedTasks = pinnedTasks.filter(categoryFilter);
      }

      // Filter tasks based on the search input
      const searchLower = search.toLowerCase();
      const searchFilter = (task: Task) =>
        task.name.toLowerCase().includes(searchLower) ||
        (task.description && task.description.toLowerCase().includes(searchLower));
      unpinnedTasks = unpinnedTasks.filter(searchFilter);
      pinnedTasks = pinnedTasks.filter(searchFilter);

      // Move done tasks to bottom if the setting is enabled
      if (user.settings[0]?.doneToBottom) {
        const doneTasks = unpinnedTasks.filter((task) => task.done);
        const notDoneTasks = unpinnedTasks.filter((task) => !task.done);
        return [...pinnedTasks, ...notDoneTasks, ...doneTasks];
      }

      return [...pinnedTasks, ...unpinnedTasks];
    },
    [search, selectedCatId, user.settings]
  );

  const confirmDeleteTask = () => {
    // Deletes the selected task

    if (selectedTaskId) {
      const updatedTasks = user.tasks.filter((task) => task.id !== selectedTaskId);
      setUser((prevUser) => ({
        ...prevUser,
        tasks: updatedTasks,
      }));

      setDeleteDialogOpen(false);
      showToast(
        <div>
          Deleted Task -{" "}
          <b translate="no">{user.tasks.find((task) => task.id === selectedTaskId)?.name}</b>
        </div>
      );
    }
  };
  const cancelDeleteTask = () => {
    // Cancels the delete task operation
    setDeleteDialogOpen(false);
  };

  const handleMarkSelectedAsDone = () => {
    setUser((prevUser) => ({
      ...prevUser,
      tasks: prevUser.tasks.map((task) => {
        if (multipleSelectedTasks.includes(task.id)) {
          // Mark the task as done if selected
          return { ...task, done: true };
        }
        return task;
      }),
    }));
    // Clear the selected task IDs after the operation
    setMultipleSelectedTasks([]);
  };

  const handleDeleteSelected = () => setDeleteSelectedOpen(true);

  useEffect(() => {
    const tasks: Task[] = reorderTasks(user.tasks);
    const uniqueCategories: Category[] = [];

    tasks.forEach((task) => {
      if (task.category) {
        task.category.forEach((category) => {
          if (!uniqueCategories.some((c) => c.id === category.id)) {
            uniqueCategories.push(category);
          }
        });
      }
    });

    // Calculate category counts
    const counts: { [categoryId: UUID]: number } = {};
    uniqueCategories.forEach((category) => {
      const categoryTasks = tasks.filter((task) =>
        task.category?.some((cat) => cat.id === category.id)
      );
      counts[category.id] = categoryTasks.length;
    });

    // Sort categories based on count
    uniqueCategories.sort((a, b) => {
      const countA = counts[a.id] || 0;
      const countB = counts[b.id] || 0;
      return countB - countA;
    });

    setCategories(uniqueCategories);
    setCategoryCounts(counts);
  }, [user.tasks, search, reorderTasks, setCategories, setCategoryCounts]);

  const checkOverdueTasks = useCallback(
    (tasks: Task[]) => {
      if (location.pathname === "/share") {
        return;
      }

      const overdueTasks = tasks.filter((task) => {
        return task.deadline && new Date() > new Date(task.deadline) && !task.done;
      });

      if (overdueTasks.length > 0) {
        const taskNames = overdueTasks.map((task) => task.name);

        showToast(
          <div translate="no" style={{ wordBreak: "break-word" }}>
            <b translate="yes">Overdue task{overdueTasks.length > 1 && "s"}: </b>
            {listFormat.format(taskNames)}
          </div>,
          {
            type: "error",
            disableVibrate: true,
            duration: 3400,
            icon: <RingAlarm animate sx={{ color: ColorPalette.red }} />,
            style: {
              borderColor: ColorPalette.red,
              boxShadow: user.settings[0].enableGlow ? `0 0 18px -8px ${ColorPalette.red}` : "none",
            },
          }
        );
      }
    },
    [listFormat, user.settings]
  );

  useEffect(() => {
    checkOverdueTasks(user.tasks);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return (
    <>
      <TaskMenu />
      <TasksContainer>
        {user.tasks.length > 0 && (
          <SearchInput
            focused
            color="primary"
            placeholder="Search for task..."
            autoComplete="off"
            value={search}
            onChange={(e) => {
              setSearch(e.target.value);
            }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <Search sx={{ color: "white" }} />
                </InputAdornment>
              ),
              endAdornment: search ? (
                <InputAdornment position="end">
                  <SearchClear
                    color={
                      reorderTasks(user.tasks).length === 0 && user.tasks.length > 0
                        ? "error"
                        : "default"
                    }
                    onClick={() => setSearch("")}
                  >
                    <Close
                      sx={{
                        color:
                          reorderTasks(user.tasks).length === 0 && user.tasks.length > 0
                            ? `${ColorPalette.red} !important`
                            : "white",
                        transition: ".3s all",
                      }}
                    />
                  </SearchClear>
                </InputAdornment>
              ) : undefined,
            }}
          />
        )}
        {categories !== undefined &&
          categories?.length > 0 &&
          user.settings[0].enableCategories && (
            <CategoriesListContainer>
              {categories?.map((cat) => (
                <CategoryBadge
                  key={cat.id}
                  category={cat}
                  emojiSizes={[24, 20]}
                  list={"true"}
                  label={
                    <div>
                      <span style={{ fontWeight: "bold" }}>{cat.name}</span>
                      <span
                        style={{
                          fontSize: "14px",
                          opacity: 0.9,
                          marginLeft: "4px",
                        }}
                      >
                        ({categoryCounts[cat.id]})
                      </span>
                    </div>
                  }
                  onClick={() =>
                    selectedCatId !== cat.id
                      ? setSelectedCatId(cat.id)
                      : setSelectedCatId(undefined)
                  }
                  onDelete={
                    selectedCatId === cat.id ? () => setSelectedCatId(undefined) : undefined
                  }
                  sx={{
                    boxShadow: "none",
                    display:
                      selectedCatId === undefined || selectedCatId === cat.id
                        ? "inline-flex"
                        : "none",
                    p: "20px 14px",
                    fontSize: "16px",
                  }}
                />
              ))}
            </CategoriesListContainer>
          )}
        {multipleSelectedTasks.length > 0 && (
          <SelectedTasksContainer>
            <div>
              <h3>
                <RadioButtonChecked /> &nbsp; Selected {multipleSelectedTasks.length} task
                {multipleSelectedTasks.length > 1 ? "s" : ""}
              </h3>
              <span translate="no" style={{ fontSize: "14px", opacity: 0.8 }}>
                {listFormat.format(
                  multipleSelectedTasks
                    .map((taskId) => user.tasks.find((task) => task.id === taskId)?.name)
                    .filter((taskName) => taskName !== undefined) as string[]
                )}
              </span>
            </div>
            {/* TODO: add more features */}
            <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
              <Tooltip title="Mark selected as done">
                <IconButton
                  sx={{ color: getFontColor(theme.secondary) }}
                  size="large"
                  onClick={handleMarkSelectedAsDone}
                >
                  <DoneAll />
                </IconButton>
              </Tooltip>
              <Tooltip title="Delete selected">
                <IconButton color="error" size="large" onClick={handleDeleteSelected}>
                  <Delete />
                </IconButton>
              </Tooltip>
              <Tooltip sx={{ color: getFontColor(theme.secondary) }} title="Cancel">
                <IconButton size="large" onClick={() => setMultipleSelectedTasks([])}>
                  <CancelRounded />
                </IconButton>
              </Tooltip>
            </div>
          </SelectedTasksContainer>
        )}
        {search && reorderTasks(user.tasks).length > 1 && user.tasks.length > 0 && (
          <div
            style={{
              textAlign: "center",
              fontSize: "18px",
              opacity: 0.9,
              marginTop: "12px",
            }}
          >
            <b>
              Found {reorderTasks(user.tasks).length} task
              {reorderTasks(user.tasks).length > 1 ? "s" : ""}
            </b>
          </div>
        )}
        {user.tasks.length !== 0 ? (
          reorderTasks(user.tasks).map((task) => (
            <TaskContainer
              key={task.id}
              id={task.id.toString()}
              // open the task menu on right click
              onContextMenu={(e) => {
                e.preventDefault();
                handleClick(e, task.id);
              }}
              backgroundColor={task.color}
              glow={user.settings[0].enableGlow}
              done={task.done}
              blur={selectedTaskId !== task.id && open && !isMobile}
            >
              {multipleSelectedTasks.length > 0 && (
                <StyledRadio
                  clr={getFontColor(task.color)}
                  checked={multipleSelectedTasks.includes(task.id)}
                  icon={<RadioUnchecked />}
                  checkedIcon={<RadioChecked />}
                  onChange={() => {
                    if (multipleSelectedTasks.includes(task.id)) {
                      setMultipleSelectedTasks((prevTasks) =>
                        prevTasks.filter((id) => id !== task.id)
                      );
                    } else {
                      handleSelectTask(task.id);
                    }
                  }}
                />
              )}
              {task.emoji || task.done ? (
                <EmojiContainer
                  clr={getFontColor(task.color)}
                  // onDoubleClick={() => handleSelectTask(task.id)}
                >
                  {task.done ? (
                    <DoneRounded fontSize="large" />
                  ) : (
                    <Emoji
                      size={
                        user.emojisStyle === EmojiStyle.NATIVE
                          ? systemInfo.os === "iOS" || systemInfo.os === "macOS"
                            ? 50
                            : 38
                          : 46
                      }
                      unified={task.emoji || ""}
                      emojiStyle={user.emojisStyle}
                      lazyLoad
                    />
                  )}
                </EmojiContainer>
              ) : null}
              <TaskInfo translate="no">
                {task.pinned && (
                  <Pinned translate="yes">
                    <PushPinRounded fontSize="small" /> &nbsp; Pinned
                  </Pinned>
                )}
                <TaskHeader>
                  <TaskName done={task.done}>{highlightMatchingText(task.name)}</TaskName>
                  <Tooltip
                    title={new Intl.DateTimeFormat(navigator.language, {
                      dateStyle: "full",
                      timeStyle: "medium",
                    }).format(new Date(task.date))}
                  >
                    <TaskDate>{formatDate(new Date(task.date))}</TaskDate>
                  </Tooltip>
                </TaskHeader>

                <TaskDescription done={task.done}>
                  <RenderTaskDescription task={task} />
                </TaskDescription>

                {task.deadline && (
                  <Tooltip
                    title={new Intl.DateTimeFormat(navigator.language, {
                      dateStyle: "full",
                      timeStyle: "medium",
                    }).format(new Date(task.deadline))}
                    placement="bottom-start"
                  >
                    <TimeLeft done={task.done} translate="yes">
                      <RingAlarm
                        fontSize="small"
                        animate={new Date() > new Date(task.deadline) && !task.done}
                        sx={{
                          color: `${getFontColor(task.color)} !important`,
                        }}
                      />{" "}
                      &nbsp;
                      {new Date(task.deadline).toLocaleDateString()} {" • "}
                      {new Date(task.deadline).toLocaleTimeString()}
                      {!task.done && (
                        <>
                          {" • "}
                          {calculateDateDifference(new Date(task.deadline))}
                        </>
                      )}
                    </TimeLeft>
                  </Tooltip>
                )}
                {task.sharedBy && (
                  <div
                    translate="yes"
                    style={{ opacity: 0.8, display: "flex", alignItems: "center", gap: "4px" }}
                  >
                    <Link /> Shared by{" "}
                    <span translate={task.sharedBy === "User" ? "yes" : "no"}>{task.sharedBy}</span>
                  </div>
                )}
                <div
                  style={{
                    display: "flex",
                    flexWrap: "wrap",
                    gap: "4px 6px",
                    justifyContent: "left",
                    alignItems: "center",
                  }}
                >
                  {task.category &&
                    user.settings[0].enableCategories &&
                    task.category.map((category) => (
                      <div key={category.id}>
                        <CategoryBadge category={category} borderclr={getFontColor(task.color)} />
                      </div>
                    ))}
                </div>
              </TaskInfo>
              <IconButton
                aria-label="Task Menu"
                aria-controls={open ? "task-menu" : undefined}
                aria-haspopup="true"
                aria-expanded={open ? "true" : undefined}
                onClick={(event) => handleClick(event, task.id)}
                sx={{ color: getFontColor(task.color) }}
              >
                <MoreVert />
              </IconButton>
            </TaskContainer>
          ))
        ) : (
          <NoTasks>
            <b>You don't have any tasks yet</b>
            <br />
            Click on the <b>+</b> button to add one
          </NoTasks>
        )}
        {search && reorderTasks(user.tasks).length === 0 && user.tasks.length > 0 && (
          <div
            style={{
              textAlign: "center",
              fontSize: "20px",
              opacity: 0.9,
              marginTop: "18px",
            }}
          >
            <b>No tasks found</b>
            <br />
            Try searching with different keywords.
            <div style={{ marginTop: "14px" }}>
              <TaskIcon scale={0.8} />
            </div>
          </div>
        )}
        <EditTask
          open={editModalOpen}
          task={user.tasks.find((task) => task.id === selectedTaskId)}
          onClose={() => setEditModalOpen(false)}
          onSave={(editedTask) => {
            const updatedTasks = user.tasks.map((task) => {
              if (task.id === editedTask.id) {
                return {
                  ...task,
                  name: editedTask.name,
                  color: editedTask.color,
                  emoji: editedTask.emoji || undefined,
                  description: editedTask.description || undefined,
                  deadline: editedTask.deadline || undefined,
                  category: editedTask.category || undefined,
                  lastSave: new Date(),
                };
              }
              return task;
            });
            setUser((prevUser) => ({
              ...prevUser,
              tasks: updatedTasks,
            }));
            setEditModalOpen(false);
          }}
        />
      </TasksContainer>
      <Dialog open={deleteDialogOpen} onClose={cancelDeleteTask}>
        <DialogTitle>Are you sure you want to delete the task?</DialogTitle>
        <DialogContent>
          {selectedTask !== undefined && (
            <>
              {selectedTask.emoji && (
                <p
                  style={{
                    display: "flex",
                    justifyContent: "left",
                    alignItems: "center",
                    gap: "6px",
                  }}
                >
                  <b>Emoji:</b>{" "}
                  <Emoji size={28} emojiStyle={user.emojisStyle} unified={selectedTask.emoji} />
                </p>
              )}
              <p>
                <b>Task Name:</b> <span translate="no">{selectedTask.name}</span>
              </p>
              {selectedTask.description && (
                <p>
                  <b>Task Description:</b>{" "}
                  <span translate="no">
                    {selectedTask.description.replace(URL_REGEX, "[link]")}
                  </span>
                </p>
              )}
              {selectedTask.category?.[0]?.name && (
                <p>
                  <b>{selectedTask.category.length > 1 ? "Categories" : "Category"}:</b>{" "}
                  <span translate="no">
                    {listFormat.format(selectedTask.category.map((cat) => cat.name))}
                  </span>
                </p>
              )}
            </>
          )}
        </DialogContent>
        <DialogActions>
          <DialogBtn onClick={cancelDeleteTask} color="primary">
            Cancel
          </DialogBtn>
          <DialogBtn onClick={confirmDeleteTask} color="error">
            <DeleteRounded /> &nbsp; Delete
          </DialogBtn>
        </DialogActions>
      </Dialog>
      <Dialog open={deleteSelectedOpen}>
        <DialogTitle>Are you sure you want to delete selected tasks?</DialogTitle>
        <DialogContent translate="no">
          {listFormat.format(
            multipleSelectedTasks
              .map((taskId) => user.tasks.find((task) => task.id === taskId)?.name)
              .filter((taskName) => taskName !== undefined) as string[]
          )}
        </DialogContent>
        <DialogActions>
          <DialogBtn onClick={() => setDeleteSelectedOpen(false)} color="primary">
            Cancel
          </DialogBtn>
          <DialogBtn
            onClick={() => {
              setUser((prevUser) => ({
                ...prevUser,
                tasks: prevUser.tasks.filter((task) => !multipleSelectedTasks.includes(task.id)),
              }));
              // Clear the selected task IDs after the operation
              setMultipleSelectedTasks([]);
              setDeleteSelectedOpen(false);
            }}
            color="error"
          >
            Delete
          </DialogBtn>
        </DialogActions>
      </Dialog>
    </>
  );
};


// File: workspace/TodoApp/src/components/tasks/TaskMenu.tsx
import styled from "@emotion/styled";
import {
  Cancel,
  Close,
  ContentCopy,
  ContentCopyRounded,
  DeleteRounded,
  Done,
  DownloadRounded,
  EditRounded,
  IosShare,
  LaunchRounded,
  LinkRounded,
  Pause,
  PlayArrow,
  PushPinRounded,
  QrCode2Rounded,
  RadioButtonChecked,
  RecordVoiceOver,
  RecordVoiceOverRounded,
} from "@mui/icons-material";
import {
  Alert,
  AlertTitle,
  Avatar,
  Box,
  Button,
  Chip,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Divider,
  IconButton,
  InputAdornment,
  Menu,
  MenuItem,
  Tab,
  Tabs,
  TextField,
  Typography,
} from "@mui/material";
import { Emoji, EmojiStyle } from "emoji-picker-react";
import { useContext, useMemo, useState } from "react";
import Marquee from "react-fast-marquee";
import toast from "react-hot-toast";
import QRCode from "react-qr-code";
import { useNavigate } from "react-router-dom";
import { BottomSheet } from "react-spring-bottom-sheet";
import "react-spring-bottom-sheet/dist/style.css";
import { TaskIcon } from "..";
import { UserContext } from "../../contexts/UserContext";
import { useResponsiveDisplay } from "../../hooks/useResponsiveDisplay";
import { DialogBtn } from "../../styles";
import { Task, UUID } from "../../types/user";
import {
  calculateDateDifference,
  getFontColor,
  saveQRCode,
  showToast,
  systemInfo,
} from "../../utils";
import { useTheme } from "@emotion/react";
import { TaskContext } from "../../contexts/TaskContext";
import { ColorPalette } from "../../theme/themeConfig";

export const TaskMenu = () => {
  const { user, setUser } = useContext(UserContext);
  const { tasks, name, settings, emojisStyle } = user;
  const {
    selectedTaskId,
    anchorEl,
    anchorPosition,
    multipleSelectedTasks,
    handleSelectTask,
    setEditModalOpen,
    handleDeleteTask,
    handleCloseMoreMenu,
  } = useContext(TaskContext);
  const [showShareDialog, setShowShareDialog] = useState<boolean>(false);
  const [shareTabVal, setShareTabVal] = useState<number>(0);

  const isMobile = useResponsiveDisplay();
  const n = useNavigate();
  const theme = useTheme();

  const selectedTask = useMemo(() => {
    return tasks.find((task) => task.id === selectedTaskId) || ({} as Task);
  }, [selectedTaskId, tasks]);

  const redirectToTaskDetails = () => {
    const taskId = selectedTask?.id.toString().replace(".", "");
    n(`/task/${taskId}`);
  };

  const generateShareableLink = (taskId: UUID | null, userName: string): string => {
    const task = tasks.find((task) => task.id === taskId);
    // This removes id property from link as a new identifier is generated on the share page.
    interface TaskToShare extends Omit<Task, "id"> {
      id: undefined;
    }

    if (task) {
      const taskToShare: TaskToShare = {
        ...task,
        sharedBy: undefined,
        id: undefined,
        category: settings[0].enableCategories ? task.category : undefined,
      };
      const encodedTask = encodeURIComponent(JSON.stringify(taskToShare));
      const encodedUserName = encodeURIComponent(userName);
      return `${window.location.href}share?task=${encodedTask}&userName=${encodedUserName}`;
    }
    return "";
  };

  const handleCopyToClipboard = async (): Promise<void> => {
    const linkToCopy = generateShareableLink(selectedTaskId, name || "User");
    try {
      await navigator.clipboard.writeText(linkToCopy);
      showToast("Copied link to clipboard.");
    } catch (error) {
      console.error("Error copying link to clipboard:", error);
      showToast("Error copying link to clipboard", { type: "error" });
    }
  };

  const handleShare = async (): Promise<void> => {
    const linkToShare = generateShareableLink(selectedTaskId, name || "User");
    if (navigator.share) {
      try {
        await navigator.share({
          title: "Share Task",
          text: `Check out this task: ${selectedTask.name}`,
          url: linkToShare,
        });
      } catch (error) {
        console.error("Error sharing link:", error);
      }
    }
  };

  const handleMarkAsDone = () => {
    // Toggles the "done" property of the selected task
    if (selectedTaskId) {
      handleCloseMoreMenu();
      const updatedTasks = tasks.map((task) => {
        if (task.id === selectedTaskId) {
          return { ...task, done: !task.done };
        }
        return task;
      });
      setUser((prevUser) => ({
        ...prevUser,
        tasks: updatedTasks,
      }));

      const allTasksDone = updatedTasks.every((task) => task.done);

      if (allTasksDone) {
        showToast(
          <div>
            <b>All tasks done</b>
            <br />
            <span>You've checked off all your todos. Well done!</span>
          </div>,
          {
            icon: (
              <div style={{ margin: "-6px 4px -6px -6px" }}>
                <TaskIcon variant="success" scale={0.18} />
              </div>
            ),
          }
        );
      }
    }
  };

  const handlePin = () => {
    // Toggles the "pinned" property of the selected task
    if (selectedTaskId) {
      handleCloseMoreMenu();
      const updatedTasks = tasks.map((task) => {
        if (task.id === selectedTaskId) {
          return { ...task, pinned: !task.pinned };
        }
        return task;
      });
      setUser((prevUser) => ({
        ...prevUser,
        tasks: updatedTasks,
      }));
    }
  };

  const handleDuplicateTask = () => {
    handleCloseMoreMenu();
    if (selectedTaskId) {
      if (selectedTask) {
        // Create a duplicated task with a new ID and current date
        const duplicatedTask: Task = {
          ...selectedTask,
          id: crypto.randomUUID(),
          date: new Date(),
          lastSave: undefined,
        };
        // Add the duplicated task to the existing tasks
        const updatedTasks = [...tasks, duplicatedTask];
        // Update the user object with the updated tasks
        setUser((prevUser) => ({
          ...prevUser,
          tasks: updatedTasks,
        }));
      }
    }
  };

  //https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis
  const handleReadAloud = () => {
    const voices = window.speechSynthesis.getVoices();
    const voice = voices.find((voice) => voice.name === settings[0].voice);
    const voiceName = voices.find((voice) => voice.name === settings[0].voice);
    const voiceVolume = settings[0].voiceVolume;
    const taskName = selectedTask?.name || "";
    const taskDescription =
      selectedTask?.description?.replace(/((?:https?):\/\/[^\s/$.?#].[^\s]*)/gi, "") || ""; // remove links from description
    // Read task date in voice language
    const taskDate = new Intl.DateTimeFormat(voice ? voice.lang : navigator.language, {
      dateStyle: "full",
      timeStyle: "short",
    }).format(new Date(selectedTask?.date || ""));

    const taskDeadline = selectedTask?.deadline
      ? ". Task Deadline: " +
        calculateDateDifference(
          new Date(selectedTask.deadline) || "",
          voice ? voice.lang : navigator.language // Read task deadline in voice language
        )
      : "";

    const textToRead = `${taskName}. ${taskDescription}. Date: ${taskDate}${taskDeadline}`;

    const utterThis: SpeechSynthesisUtterance = new SpeechSynthesisUtterance(textToRead);

    if (voiceName) {
      utterThis.voice = voiceName;
    }

    if (voiceVolume) {
      utterThis.volume = voiceVolume;
    }

    handleCloseMoreMenu();

    const pauseSpeech = () => {
      window.speechSynthesis.pause();
    };

    const resumeSpeech = () => {
      window.speechSynthesis.resume();
    };

    const cancelSpeech = () => {
      window.speechSynthesis.cancel();
      toast.dismiss(SpeechToastId);
      handleCloseMoreMenu();
    };

    const SpeechToastId = toast(
      () => {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const [isPlaying, setIsPlaying] = useState<boolean>(true);
        return (
          <ReadAloudContainer>
            <ReadAloudHeader translate="yes">
              <RecordVoiceOver /> Read aloud: <span translate="no">{selectedTask?.name}</span>
            </ReadAloudHeader>
            <span translate="yes" style={{ marginTop: "8px", fontSize: "16px" }}>
              Voice: <span translate="no">{utterThis.voice?.name || "Default"}</span>
            </span>
            <div translate="no">
              <Marquee delay={0.6} play={isPlaying}>
                <p style={{ margin: "6px 0" }}>{utterThis.text} &nbsp;</p>
              </Marquee>
            </div>
            <ReadAloudControls>
              {isPlaying ? (
                <IconButton
                  onClick={() => {
                    pauseSpeech();
                    setIsPlaying(!isPlaying);
                  }}
                >
                  <Pause fontSize="large" />
                </IconButton>
              ) : (
                <IconButton
                  onClick={() => {
                    resumeSpeech();
                    setIsPlaying(!isPlaying);
                  }}
                >
                  <PlayArrow fontSize="large" />
                </IconButton>
              )}
              <IconButton onClick={cancelSpeech}>
                <Cancel fontSize="large" />
              </IconButton>
            </ReadAloudControls>
          </ReadAloudContainer>
        );
      },
      {
        duration: 999999999,
        style: {
          border: `1px solid ${theme.darkmode ? "#1b1d4eb7" : "#ededf7b0"} `,
          WebkitBackdropFilter: `blur(${theme.darkmode ? "10" : "14"}px)`,
          backdropFilter: `blur(${theme.darkmode ? "10" : "14"}px)`,
        },
      }
    );

    // Set up event listener for the end of speech
    utterThis.onend = () => {
      // Close the menu
      handleCloseMoreMenu();
      // Hide the toast when speech ends
      toast.dismiss(SpeechToastId);
    };
    if (voiceVolume > 0) {
      window.speechSynthesis.speak(utterThis);
    }
  };

  const menuItems: JSX.Element = (
    <div>
      <StyledMenuItem onClick={handleMarkAsDone}>
        {selectedTask.done ? <Close /> : <Done />}
        &nbsp; {selectedTask.done ? "Mark as not done" : "Mark as done"}
      </StyledMenuItem>
      <StyledMenuItem onClick={handlePin}>
        <PushPinRounded sx={{ textDecoration: "line-through" }} />
        &nbsp; {selectedTask.pinned ? "Unpin" : "Pin"}
      </StyledMenuItem>

      {multipleSelectedTasks.length === 0 && (
        <StyledMenuItem onClick={() => handleSelectTask(selectedTaskId || crypto.randomUUID())}>
          <RadioButtonChecked /> &nbsp; Select
        </StyledMenuItem>
      )}

      <StyledMenuItem onClick={redirectToTaskDetails}>
        <LaunchRounded /> &nbsp; Task details
      </StyledMenuItem>

      {settings[0].enableReadAloud && (
        <StyledMenuItem
          onClick={handleReadAloud}
          disabled={window.speechSynthesis.speaking || window.speechSynthesis.pending}
        >
          <RecordVoiceOverRounded /> &nbsp; Read Aloud
        </StyledMenuItem>
      )}

      <StyledMenuItem
        onClick={() => {
          setShowShareDialog(true);
          handleCloseMoreMenu();
        }}
      >
        <LinkRounded /> &nbsp; Share
      </StyledMenuItem>

      <Divider />
      <StyledMenuItem
        onClick={() => {
          setEditModalOpen(true);
          handleCloseMoreMenu();
        }}
      >
        <EditRounded /> &nbsp; Edit
      </StyledMenuItem>
      <StyledMenuItem onClick={handleDuplicateTask}>
        <ContentCopy /> &nbsp; Duplicate
      </StyledMenuItem>
      <Divider />
      <StyledMenuItem
        clr={ColorPalette.red}
        onClick={() => {
          handleDeleteTask();
          handleCloseMoreMenu();
        }}
      >
        <DeleteRounded /> &nbsp; Delete
      </StyledMenuItem>
    </div>
  );

  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {
    setShareTabVal(newValue);
  };
  return (
    <>
      {isMobile ? (
        <BottomSheet
          open={Boolean(anchorEl)}
          onDismiss={handleCloseMoreMenu}
          snapPoints={({ minHeight, maxHeight }) => [minHeight, maxHeight]}
          expandOnContentDrag
          header={
            <SheetHeader translate="no">
              <Emoji emojiStyle={emojisStyle} size={32} unified={selectedTask.emoji || ""} />{" "}
              {emojisStyle === EmojiStyle.NATIVE && "\u00A0 "}
              {selectedTask.name}
            </SheetHeader>
          }
        >
          <SheetContent>{menuItems}</SheetContent>
        </BottomSheet>
      ) : (
        <Menu
          id="task-menu"
          anchorEl={anchorEl}
          anchorPosition={anchorPosition ? anchorPosition : undefined}
          anchorReference={anchorPosition ? "anchorPosition" : undefined}
          open={Boolean(anchorEl)}
          onClose={handleCloseMoreMenu}
          sx={{
            "& .MuiPaper-root": {
              borderRadius: "18px",
              minWidth: "200px",
              boxShadow: "none",
              padding: "6px 4px",
            },
          }}
          MenuListProps={{
            "aria-labelledby": "more-button",
          }}
        >
          {menuItems}
        </Menu>
      )}
      <Dialog
        open={showShareDialog}
        onClose={() => setShowShareDialog(false)}
        PaperProps={{
          style: {
            borderRadius: "28px",
            padding: "10px",
            width: "560px",
          },
        }}
      >
        <DialogTitle>Share Task</DialogTitle>
        <DialogContent>
          <div style={{ display: "flex", alignItems: "center", gap: "6px" }}>
            <ShareTaskChip
              translate="no"
              label={selectedTask.name}
              clr={selectedTask.color}
              avatar={
                selectedTask.emoji ? (
                  <Avatar sx={{ background: "transparent", borderRadius: "0" }}>
                    <Emoji
                      unified={selectedTask.emoji || ""}
                      emojiStyle={emojisStyle}
                      size={
                        emojisStyle === EmojiStyle.NATIVE
                          ? systemInfo.os === "iOS" || systemInfo.os === "macOS"
                            ? 24
                            : 18
                          : 24
                      }
                    />
                  </Avatar>
                ) : undefined
              }
            />
          </div>
          <Tabs value={shareTabVal} onChange={handleTabChange} sx={{ m: "8px 0" }}>
            <StyledTab label="Link" icon={<LinkRounded />} />
            <StyledTab label="QR Code" icon={<QrCode2Rounded />} />
          </Tabs>
          <CustomTabPanel value={shareTabVal} index={0}>
            <ShareField
              value={generateShareableLink(selectedTaskId, name || "User")}
              fullWidth
              variant="outlined"
              label="Shareable Link"
              InputProps={{
                readOnly: true,
                startAdornment: (
                  <InputAdornment position="start">
                    <LinkRounded sx={{ ml: "8px" }} />
                  </InputAdornment>
                ),
                endAdornment: (
                  <InputAdornment position="end">
                    <Button
                      onClick={() => {
                        handleCopyToClipboard();
                      }}
                      sx={{ p: "12px", borderRadius: "14px", mr: "4px" }}
                    >
                      <ContentCopyRounded /> &nbsp; Copy
                    </Button>
                  </InputAdornment>
                ),
              }}
              sx={{
                mt: 3,
              }}
            />
          </CustomTabPanel>
          <CustomTabPanel value={shareTabVal} index={1}>
            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                marginTop: "22px",
              }}
            >
              <QRCode
                id="QRCodeShare"
                value={generateShareableLink(selectedTaskId, name || "User")}
                size={400}
              />
            </Box>
            <Box
              sx={{
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
              }}
            >
              <DownloadQrCodeBtn
                variant="outlined"
                onClick={() => saveQRCode(selectedTask.name || "")}
              >
                <DownloadRounded /> &nbsp; Download QR Code
              </DownloadQrCodeBtn>
            </Box>
          </CustomTabPanel>
          <Alert severity="info" sx={{ mt: "20px" }}>
            <AlertTitle>Share Your Task</AlertTitle>
            Share your task with others using the link or QR code. Copy the link to share manually
            or use the share button to send it via other apps. You can also download the QR code for
            easy access.
          </Alert>
          {/* <Alert severity="warning" sx={{ mt: "8px" }}>
            Anyone with access to this link will be able to view your name and task details.
          </Alert> */}
        </DialogContent>
        <DialogActions>
          <DialogBtn onClick={() => setShowShareDialog(false)}>Close</DialogBtn>
          <DialogBtn onClick={handleShare}>
            <IosShare sx={{ mb: "4px" }} /> &nbsp; Share
          </DialogBtn>
        </DialogActions>
      </Dialog>
    </>
  );
};
interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}
const CustomTabPanel = ({ children, value, index }: TabPanelProps) => {
  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`share-tabpanel-${index}`}
      aria-labelledby={`share-tab-${index}`}
    >
      {value === index && (
        <Box>
          <Typography>{children}</Typography>
        </Box>
      )}
    </div>
  );
};
const SheetHeader = styled.h3`
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 6px;
  color: ${({ theme }) => (theme.darkmode ? ColorPalette.fontLight : ColorPalette.fontDark)};
  margin: 10px;
  font-size: 20px;
`;

const SheetContent = styled.div`
  color: ${({ theme }) => (theme.darkmode ? ColorPalette.fontLight : ColorPalette.fontDark)};
  margin: 20px 10px;
  & .MuiMenuItem-root {
    font-size: 16px;
    padding: 16px;
    &::before {
      content: "";
      display: inline-block;
      margin-right: 10px;
    }
  }
`;
const StyledMenuItem = styled(MenuItem)<{ clr?: string }>`
  margin: 0 6px;
  padding: 12px;
  border-radius: 12px;
  box-shadow: none;
  gap: 2px;
  color: ${({ clr }) => clr || "unset"};
`;

const ReadAloudContainer = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
`;

const ReadAloudHeader = styled.div`
  display: inline-flex;
  align-items: center;
  font-weight: 600;
  gap: 6px;
`;

const ReadAloudControls = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 16px;
  gap: 8px;
`;

const ShareField = styled(TextField)`
  margin-top: 22px;
  .MuiOutlinedInput-root {
    border-radius: 14px;
    padding: 2px;
    transition: 0.3s all;
  }
`;

const ShareTaskChip = styled(Chip)<{ clr: string }>`
  background: ${({ clr }) => clr};
  color: ${({ clr }) => getFontColor(clr)};
  font-size: 14px;
  padding: 18px 8px;
  border-radius: 50px;
  font-weight: 500;
  margin-left: 6px;
  @media (max-width: 768px) {
    font-size: 16px;
    padding: 20px 10px;
  }
`;

const DownloadQrCodeBtn = styled(Button)`
  padding: 12px 24px;
  border-radius: 14px;
  margin-top: 16px;
  @media (max-width: 520px) {
    margin-top: -2px;
  }
`;

const StyledTab = styled(Tab)`
  border-radius: 12px 12px 0 0;
  width: 50%;
  .MuiTabs-indicator {
    border-radius: 24px;
  }
`;
StyledTab.defaultProps = {
  iconPosition: "start",
};


// File: workspace/TodoApp/src/layouts/MainLayout.tsx
import { ReactNode } from "react";
import { BottomNav, ProfileSidebar } from "../components";

interface MainLayoutProps {
  children: ReactNode;
}

const MainLayout = ({ children }: MainLayoutProps) => {
  return (
    <>
      <ProfileSidebar />
      {children}
      <div style={{ marginTop: "128px" }} />
      <BottomNav />
    </>
  );
};

export default MainLayout;


// File: workspace/TodoApp/src/theme/themeConfig.ts
export const ColorPalette = {
  fontDark: "#101727",
  fontLight: "#f0f0f0",
  darkMode: "#383838", // TODO: add dark and light mode colors
  lightMode: "#ffffff",
  purple: "#b624ff",
  red: "#ff3131",
  orange: "#ff9318",
} as const;

type ThemeConfig = {
  [key: string]: {
    primaryColor: string;
    secondaryColor?: string;
  };
};

export const themeConfig: ThemeConfig = {
  Purple: {
    // Default dark theme
    primaryColor: ColorPalette.purple,
  },
  "Light Purple": {
    // Default light theme
    primaryColor: ColorPalette.purple,
    secondaryColor: "#edeef6",
  },
  Blue: {
    primaryColor: "#2a93d5",
  },
  "Minty Fresh": {
    primaryColor: "#26C6DA",
    secondaryColor: "#E0F7FA",
  },
  Pink: {
    primaryColor: "#e5369a",
  },
  "Blush Blossom": {
    primaryColor: "#EC407A",
    secondaryColor: "#FCE4EC",
  },
  "Ultra Pink": {
    primaryColor: "#ff0090",
    secondaryColor: "#ff94d1",
  },
  Cheesecake: {
    primaryColor: "#E14C94",
    secondaryColor: "#FDF0D5",
  },
  "Dark Orange": {
    primaryColor: "#FF5631",
    secondaryColor: "#0D0D0D",
  },
  "Light Orange": {
    primaryColor: "#F26E56",
    secondaryColor: "#F6F6F6",
  },
  Aurora: {
    primaryColor: "#00e952",
    secondaryColor: "#011926",
  },
  // Add new themes here
};


// File: workspace/TodoApp/src/theme/theme.ts
import { createTheme } from "@mui/material";
import type { Theme } from "@mui/material";
import { ColorPalette, themeConfig } from "./themeConfig";
import { muiComponentsProps } from "./muiComponents";

export const createCustomTheme = (
  primaryColor: string,
  backgroundColor = "#232e58",
  mode: "light" | "dark" = "dark"
): Theme => {
  return createTheme({
    components: {
      ...muiComponentsProps,
    },
    palette: {
      primary: {
        main: primaryColor,
      },
      secondary: {
        main: backgroundColor,
      },
      warning: {
        main: ColorPalette.orange,
      },
      error: {
        main: ColorPalette.red,
      },
      // background: {
      //   paper: mode === "dark" ? ColorPalette.darkMode : ColorPalette.lightMode,
      // },
      mode,
    },
  });
};

export const Themes: { name: string; MuiTheme: Theme }[] = Object.entries(themeConfig).map(
  ([name, config]) => ({
    name: name as string,
    MuiTheme: createCustomTheme(config.primaryColor, config.secondaryColor),
  })
);


// File: workspace/TodoApp/src/theme/muiComponents.ts
import type { Theme } from "@mui/material";

export const muiComponentsProps: Theme["components"] = {
  MuiTooltip: {
    defaultProps: {
      disableInteractive: true,
      style: {
        backdropFilter: "blur(6px)",
        WebkitBackdropFilter: "blur(6px)",
      },
    },
  },
  MuiButton: {
    defaultProps: {
      sx: {
        p: "12px 24px",
        borderRadius: "14px",
      },
    },
  },
  MuiSelect: {
    defaultProps: {
      style: {
        borderRadius: "18px",
      },
    },
  },
  MuiDialog: {
    defaultProps: {
      PaperProps: {
        style: {
          padding: "12px",
          borderRadius: "24px",
        },
      },
    },
  },
  MuiAvatar: {
    defaultProps: {
      style: {
        fontWeight: 500,
        color: "#fff",
      },
    },
  },
  MuiAlert: {
    styleOverrides: {
      root: {
        borderRadius: "16px",
      },
    },
  },
  MuiTextField: {
    styleOverrides: {
      root: {
        "& .MuiInputBase-root": {
          borderRadius: "16px",
        },
      },
    },
  },
};


// File: workspace/TodoApp/src/hooks/useSystemTheme.ts
import { useState, useEffect } from "react";

type Theme = "light" | "dark" | "unknown";

/**
 * A React hook to detect the system theme preference.
 * @returns The current system theme ('light', 'dark', or 'unknown').
 */
export const useSystemTheme = (): Theme => {
  const [theme, setTheme] = useState<Theme>("unknown");
  useEffect(() => {
    const mediaQueryListener = (e: MediaQueryListEvent) => {
      setTheme(e.matches ? "dark" : "light");
    };

    const prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");
    setTheme(prefersDarkScheme.matches ? "dark" : "light");

    // Listen for changes in system theme
    prefersDarkScheme.addEventListener("change", mediaQueryListener);

    return () => {
      prefersDarkScheme.removeEventListener("change", mediaQueryListener);
    };
  }, []);

  return theme;
};


// File: workspace/TodoApp/src/hooks/useResponsiveDisplay.ts
import { useEffect, useState } from "react";
/**
 * A custom React hook to determine if the current device is a smaller device
 * based on the screen width.
 * @param [breakpoint=768] - The breakpoint in pixels at which a device is considered "smaller".
 * @returns {boolean} - A boolean value indicating whether the current device is a smaller device.
 */
export const useResponsiveDisplay = (breakpoint = 768): boolean => {
  const [isSmallerDevice, setIsSmallerDevice] = useState<boolean>(false);

  useEffect(() => {
    const checkScreenSize = () => {
      setIsSmallerDevice(window.innerWidth < breakpoint);
    };
    checkScreenSize();
    const handleResize = () => checkScreenSize();
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, [breakpoint]);

  return isSmallerDevice;
};


// File: workspace/TodoApp/src/hooks/useOnlineStatus.ts
import { useState, useEffect } from "react";

/**
 * Hook that checks if a user is currently online.
 * @returns {boolean} Whether or not the user is online.
 */
export const useOnlineStatus = (): boolean => {
  const [isOnline, setIsOnline] = useState<boolean>(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, []);

  return isOnline;
};


// File: workspace/TodoApp/src/hooks/useStorageState.ts
import { useState, useEffect } from "react";

type StorageType = "localStorage" | "sessionStorage";

/**
 * A custom React hook that returns a stateful value and a function to update it, and persists the value in storage.
 * @param {any} defaultValue - The default value for the state.
 * @param {string} key - The key under which the value will be stored.
 * @param {StorageType} storageType - The type of storage to use ("localStorage" or "sessionStorage").
 * @returns {[any, Function]} A tuple containing the current state value and a function to update it.
 * @example const [count, setCount] = useStorageState(1, "count", "localStorage");
 */
export function useStorageState<T>(
  defaultValue: T,
  key: string,
  storageType: StorageType = "localStorage"
): [T, React.Dispatch<React.SetStateAction<T>>] {
  const storage = window[storageType];

  // Initialize state with the stored value or the default value
  const [value, setValue] = useState<T>(() => {
    const storedValue = storage.getItem(key);
    return storedValue !== null && storedValue !== undefined && storedValue !== "undefined"
      ? JSON.parse(storedValue)
      : defaultValue;
  });

  // Update storage whenever the key or value changes
  useEffect(() => {
    storage.setItem(key, JSON.stringify(value));
  }, [key, value, storage]);

  // This allows to synchronize localStorage between tabs in real time

  // Listen for storage events and update state if the key matches
  useEffect(() => {
    const handleStorageChange = (event: StorageEvent) => {
      if (event.key === key && event.newValue !== null && event.key !== "") {
        setValue(JSON.parse(event.newValue));
      }
    };

    window.addEventListener("storage", handleStorageChange);

    return () => {
      window.removeEventListener("storage", handleStorageChange);
    };
  }, [key]);

  // Return the state value and update function
  return [value, setValue];
}


// File: workspace/TodoApp/src/hooks/useCtrlS.ts
import { useContext, useEffect } from "react";
import { exportTasksToJson } from "../utils";
import { UserContext } from "../contexts/UserContext";

/**
 * Custom React hook that enables saving tasks to JSON when the user presses Ctrl + S.
 * @returns {void}
 */
export const useCtrlS = (): void => {
  const { user } = useContext(UserContext);
  const { tasks } = user;

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Check if the key combination is Ctrl + S
      if ((e.key === "s" || e.key === "S") && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        const userConfirmed = window.confirm("Do you want to save all tasks to JSON?");
        if (userConfirmed) {
          exportTasksToJson(tasks);
        }
      }
    };

    document.addEventListener("keydown", handleKeyDown);

    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [tasks]);
};


// File: workspace/TodoApp/src/pages/UserProfile.tsx
import {
  Avatar,
  Badge,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Grid,
  IconButton,
  InputAdornment,
  TextField,
  Tooltip,
} from "@mui/material";
import { useContext, useEffect, useState } from "react";
import styled from "@emotion/styled";
import {
  AddAPhotoRounded,
  CheckRounded,
  Delete,
  LinkRounded,
  Logout,
  PersonalVideoRounded,
  SaveRounded,
  Settings,
  TodayRounded,
} from "@mui/icons-material";
import { PROFILE_PICTURE_MAX_LENGTH, USER_NAME_MAX_LENGTH } from "../constants";
import { SettingsDialog, TopBar } from "../components";
import { ColorElement, DialogBtn, UserAvatar } from "../styles";
import { defaultUser } from "../constants/defaultUser";
import { UserContext } from "../contexts/UserContext";
import { timeAgo, getFontColor, showToast } from "../utils";
import { useSystemTheme } from "../hooks/useSystemTheme";
import { Themes } from "../theme/theme";
import { ColorPalette } from "../theme/themeConfig";

const UserProfile = () => {
  const { user, setUser } = useContext(UserContext);
  const { name, profilePicture, createdAt } = user;
  const [userName, setUserName] = useState<string>("");
  const [profilePictureURL, setProfilePictureURL] = useState<string>("");
  const [openChangeImage, setOpenChangeImage] = useState<boolean>(false);
  const [logoutConfirmationOpen, setLogoutConfirmationOpen] = useState<boolean>(false);
  const [openSettings, setOpenSettings] = useState<boolean>(false);

  const systemTheme = useSystemTheme();

  useEffect(() => {
    document.title = `Todo App - User ${name ? `(${name})` : ""}`;
  }, [name]);

  const handleSaveName = () => {
    if (userName.length <= USER_NAME_MAX_LENGTH && userName !== name) {
      setUser({ ...user, name: userName });

      showToast(
        <div>
          Changed user name
          {userName && (
            <>
              {" "}
              to <b translate="no">{userName}</b>
            </>
          )}
          .
        </div>
      );

      setUserName("");
    }
  };

  const handleOpenImageDialog = () => {
    setOpenChangeImage(true);
  };
  const handleCloseImageDialog = () => {
    setOpenChangeImage(false);
  };

  const handleLogoutConfirmationClose = () => {
    setLogoutConfirmationOpen(false);
  };
  const handleLogout = () => {
    setUser(defaultUser);
    handleLogoutConfirmationClose();
    showToast("You have been successfully logged out");
  };

  const handleSaveImage = () => {
    if (
      profilePictureURL.length <= PROFILE_PICTURE_MAX_LENGTH &&
      profilePictureURL.startsWith("https://")
    ) {
      handleCloseImageDialog();
      setUser((prevUser) => ({
        ...prevUser,
        profilePicture: profilePictureURL,
      }));
      showToast("Changed profile picture.");
    }
  };

  return (
    <>
      <TopBar title="User Profile" />
      <Container>
        <Tooltip title="App Settings">
          <IconButton
            onClick={() => setOpenSettings(true)}
            aria-label="Settings"
            size="large"
            sx={{
              position: "absolute",
              top: "24px",
              right: "24px",
            }}
          >
            <Settings fontSize="large" />
          </IconButton>
        </Tooltip>
        <Tooltip title={profilePicture ? "Change profile picture" : "Add profile picture"}>
          <Badge
            overlap="circular"
            anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
            badgeContent={
              <Avatar
                onClick={handleOpenImageDialog}
                sx={{
                  background: "#9c9c9c81",
                  backdropFilter: "blur(10px)",
                  cursor: "pointer",
                }}
              >
                <AddAPhotoRounded />
              </Avatar>
            }
          >
            <UserAvatar
              onClick={handleOpenImageDialog}
              src={profilePicture || undefined}
              hasImage={profilePicture !== null}
              size="96px"
            >
              {name ? name[0].toUpperCase() : undefined}
            </UserAvatar>
          </Badge>
        </Tooltip>
        <UserName translate={name ? "no" : "yes"}>{name || "User"}</UserName>
        <Tooltip
          title={new Intl.DateTimeFormat(navigator.language, {
            dateStyle: "full",
            timeStyle: "medium",
          }).format(new Date(createdAt))}
        >
          <CreatedAtDate>
            <TodayRounded fontSize="small" />
            &nbsp;Registered {timeAgo(createdAt)}
          </CreatedAtDate>
        </Tooltip>

        <ThemePickerContainer
          container
          maxWidth="300px"
          marginBottom="6px"
          marginTop="1px"
          display="flex"
          justifyContent="left"
          alignItems="center"
          gap={1}
        >
          <Grid item>
            <Tooltip title={`System (${systemTheme})`}>
              <ColorElement
                clr={systemTheme === "dark" || systemTheme === "unknown" ? "#3d3e59" : "#ffffff"}
                style={{ transition: ".3s background" }}
                size="40px"
                onClick={() => {
                  setUser((prevUser) => ({
                    ...prevUser,
                    theme: "system",
                  }));
                }}
              >
                <Badge badgeContent={user.theme === "system" ? <CheckIcon /> : undefined}>
                  <PersonalVideoRounded
                    sx={{ color: systemTheme === "dark" ? "white" : "black" }}
                  />
                </Badge>
              </ColorElement>
            </Tooltip>
          </Grid>
          {Themes.map((theme) => (
            <Grid key={theme.name}>
              <Tooltip title={theme.name[0].toUpperCase() + theme.name.replace(theme.name[0], "")}>
                <ColorElement
                  clr={theme.MuiTheme.palette.primary.main}
                  secondClr={theme.MuiTheme.palette.secondary.main}
                  aria-label={`Change theme - ${theme.name}`}
                  size="40px"
                  style={{
                    border:
                      user.theme === theme.name
                        ? `3px solid ${theme.MuiTheme.palette.primary.main}`
                        : "none",
                  }}
                  onClick={() => {
                    setUser((prevUser) => ({
                      ...prevUser,
                      theme: theme.name,
                    }));
                  }}
                >
                  <Badge badgeContent={user.theme === theme.name ? <CheckIcon /> : undefined}>
                    <div style={{ width: "24px", height: "24px" }} />
                  </Badge>
                </ColorElement>
              </Tooltip>
            </Grid>
          ))}
        </ThemePickerContainer>
        <TextField
          sx={{ width: "300px" }}
          label={name === null ? "Add Name" : "Change Name"}
          value={userName}
          onChange={(e) => setUserName(e.target.value)}
          onKeyDown={(e) => e.key === "Enter" && handleSaveName()}
          error={userName.length > USER_NAME_MAX_LENGTH || (userName === name && name !== "")}
          helperText={
            userName.length > USER_NAME_MAX_LENGTH
              ? `Name exceeds ${USER_NAME_MAX_LENGTH} characters`
              : userName.length > 0 && userName !== name
              ? `${userName.length}/${USER_NAME_MAX_LENGTH}`
              : userName === name && name !== ""
              ? "New username matches old one."
              : ""
          }
          autoComplete="nickname"
        />

        <SaveBtn
          onClick={handleSaveName}
          disabled={userName.length > USER_NAME_MAX_LENGTH || userName === name}
        >
          Save name
        </SaveBtn>
        <Button
          color="error"
          variant="outlined"
          sx={{ p: "12px 20px", borderRadius: "14px", marginTop: "8px" }}
          onClick={() => setLogoutConfirmationOpen(true)}
        >
          <Logout />
          &nbsp; Logout
        </Button>
      </Container>
      <Dialog open={openChangeImage} onClose={handleCloseImageDialog}>
        <DialogTitle>Change Profile Picture</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            label="Link to profile picture"
            placeholder="Enter link to profile picture..."
            sx={{ my: "8px", width: "300px" }}
            value={profilePictureURL}
            onChange={(e) => {
              setProfilePictureURL(e.target.value);
            }}
            onKeyDown={(e) => e.key === "Enter" && handleSaveImage()}
            error={profilePictureURL.length > PROFILE_PICTURE_MAX_LENGTH}
            helperText={
              profilePictureURL.length > PROFILE_PICTURE_MAX_LENGTH
                ? `URL is too long maximum ${PROFILE_PICTURE_MAX_LENGTH} characters`
                : ""
            }
            autoComplete="url"
            type="url"
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <LinkRounded />
                </InputAdornment>
              ),
            }}
          />

          <br />
          {profilePicture !== null && (
            <Button
              fullWidth
              onClick={() => {
                handleCloseImageDialog();
                showToast("Deleted profile image.");
                setUser({ ...user, profilePicture: null });
              }}
              color="error"
              variant="outlined"
              sx={{ margin: "16px 0", p: "12px 20px", borderRadius: "14px" }}
            >
              <Delete /> &nbsp; Delete Image
            </Button>
          )}
        </DialogContent>
        <DialogActions>
          <DialogBtn onClick={handleCloseImageDialog}>Cancel</DialogBtn>
          <DialogBtn
            disabled={
              profilePictureURL.length > PROFILE_PICTURE_MAX_LENGTH ||
              !profilePictureURL.startsWith("https://")
            }
            onClick={handleSaveImage}
          >
            <SaveRounded /> &nbsp; Save
          </DialogBtn>
        </DialogActions>
      </Dialog>
      <Dialog open={logoutConfirmationOpen} onClose={handleLogoutConfirmationClose}>
        <DialogTitle>Logout Confirmation</DialogTitle>
        <DialogContent>
          Are you sure you want to logout? <b>Your tasks will not be saved.</b>
        </DialogContent>
        <DialogActions>
          <DialogBtn onClick={handleLogoutConfirmationClose}>Cancel</DialogBtn>
          <DialogBtn onClick={handleLogout} color="error">
            <Logout /> &nbsp; Logout
          </DialogBtn>
        </DialogActions>
      </Dialog>
      <SettingsDialog open={openSettings} onClose={() => setOpenSettings(false)} />
    </>
  );
};

export default UserProfile;

const Container = styled.div`
  margin: 0 auto;
  max-width: 400px;
  padding: 64px 48px;
  border-radius: 48px;
  box-shadow: 0px 4px 50px rgba(0, 0, 0, 0.25);
  background: ${({ theme }) => (theme.darkmode ? "#383838" : "#f5f5f5")};
  color: ${({ theme }) => (theme.darkmode ? ColorPalette.fontLight : ColorPalette.fontDark)};
  transition: border 0.3s, box-shadow 0.3s;
  border: 4px solid ${({ theme }) => theme.primary};
  box-shadow: 0 0 72px -1px ${({ theme }) => theme.primary + "bf"};
  display: flex;
  gap: 14px;
  flex-direction: column;
  align-items: center;
  flex-direction: column;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
`;

const CheckIcon = styled(CheckRounded)`
  font-size: 18px;
  padding: 2px;
  color: white;
  background: #242427;
  border-radius: 100px;
`;

const ThemePickerContainer = styled(Grid)`
  background: ${({ theme }) => (theme.darkmode ? "#505050" : "#d9d9d9")};
  padding: 10px;
  border-radius: 32px;
  overflow-y: auto;
`;

const SaveBtn = styled(Button)`
  width: 300px;
  font-weight: 600;
  border: none;
  background: ${({ theme }) => theme.primary};
  color: ${({ theme }) => getFontColor(theme.primary)};
  font-size: 18px;
  padding: 14px;
  border-radius: 16px;
  cursor: pointer;
  text-transform: capitalize;
  transition: background 0.3s, color 0.3s;
  &:hover {
    background: ${({ theme }) => theme.primary};
  }
  &:disabled {
    cursor: not-allowed;
    opacity: 0.7;
    color: white;
  }
`;

const UserName = styled.span`
  font-size: 20px;
  font-weight: 500;
`;

const CreatedAtDate = styled.span`
  display: flex;
  align-items: center;
  font-style: italic;
  font-weight: 400;
  opacity: 0.8;
  margin-top: -5px;
  margin-bottom: 2px;
  // fix for browser translate
  & font {
    margin: 0 1px;
  }
`;


// File: workspace/TodoApp/src/pages/Home.tsx
import { useState, useEffect, ReactNode, useContext, useMemo, lazy, Suspense } from "react";
import {
  AddButton,
  GreetingHeader,
  GreetingText,
  Offline,
  ProgressPercentageContainer,
  StyledProgress,
  TaskCompletionText,
  TaskCountHeader,
  TaskCountTextContainer,
  TasksCount,
  TasksCountContainer,
} from "../styles";

import { displayGreeting, getRandomGreeting, getTaskCompletionText } from "../utils";
import { Emoji } from "emoji-picker-react";
import { Box, Tooltip, Typography } from "@mui/material";
import { useOnlineStatus } from "../hooks/useOnlineStatus";
import { AddRounded, TodayRounded, WifiOff } from "@mui/icons-material";
import { UserContext } from "../contexts/UserContext";
import { useResponsiveDisplay } from "../hooks/useResponsiveDisplay";
import { useNavigate } from "react-router-dom";
import { TaskProvider } from "../contexts/TaskProvider";

const TasksList = lazy(() =>
  import("../components/tasks/TasksList").then((module) => ({ default: module.TasksList }))
);

const Home = () => {
  const { user } = useContext(UserContext);
  const { tasks, emojisStyle, settings, name } = user;
  const [randomGreeting, setRandomGreeting] = useState<string | ReactNode>("");
  const [greetingKey, setGreetingKey] = useState<number>(0);
  const [completedTasksCount, setCompletedTasksCount] = useState<number>(0);

  const [tasksWithDeadlineTodayCount, setTasksWithDeadlineTodayCount] = useState<number>(0);
  const [tasksDueTodayNames, setTasksDueTodayNames] = useState<string[]>([]);

  const completedTaskPercentage = useMemo<number>(
    () => (completedTasksCount / tasks.length) * 100,
    [completedTasksCount, tasks.length]
  );

  const isOnline = useOnlineStatus();
  const n = useNavigate();
  const isMobile = useResponsiveDisplay();

  useEffect(() => {
    setRandomGreeting(getRandomGreeting());
    document.title = "Todo App";

    const interval = setInterval(() => {
      setRandomGreeting(getRandomGreeting());
      setGreetingKey((prevKey) => prevKey + 1); // Update the key on each interval
    }, 6000);

    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    const completedCount = tasks.filter((task) => task.done).length;
    setCompletedTasksCount(completedCount);

    const today = new Date().setHours(0, 0, 0, 0);

    const dueTodayTasks = tasks.filter((task) => {
      if (task.deadline) {
        const taskDeadline = new Date(task.deadline).setHours(0, 0, 0, 0);
        return taskDeadline === today && !task.done;
      }
      return false;
    });

    setTasksWithDeadlineTodayCount(dueTodayTasks.length);

    // Use Intl to format and display task names due today
    const taskNamesDueToday = dueTodayTasks.map((task) => task.name);
    setTasksDueTodayNames(taskNamesDueToday);
  }, [tasks]);

  const replaceEmojiCodes = (text: string): ReactNode[] => {
    const emojiRegex = /\*\*(.*?)\*\*/g;
    const parts = text.split(emojiRegex);

    return parts.map((part, index) => {
      if (index % 2 === 1) {
        // It's an emoji code, render Emoji component
        const emojiCode = part.trim();
        return <Emoji key={index} size={20} unified={emojiCode} emojiStyle={emojisStyle} />;
      } else {
        // It's regular text
        return part;
      }
    });
  };

  const renderGreetingWithEmojis = (text: string | ReactNode) => {
    if (typeof text === "string") {
      return replaceEmojiCodes(text);
    } else {
      // It's already a ReactNode, no need to process
      return text;
    }
  };

  return (
    <>
      <GreetingHeader>
        <Emoji unified="1f44b" emojiStyle={emojisStyle} /> &nbsp; {displayGreeting()}
        {name && (
          <span translate="no">
            , <span>{name}</span>
          </span>
        )}
      </GreetingHeader>
      <GreetingText key={greetingKey}>{renderGreetingWithEmojis(randomGreeting)}</GreetingText>
      {!isOnline && (
        <Offline>
          <WifiOff /> You're offline but you can use the app!
        </Offline>
      )}
      {tasks.length > 0 && (
        <TasksCountContainer>
          <TasksCount glow={settings[0].enableGlow}>
            <Box sx={{ position: "relative", display: "inline-flex" }}>
              <StyledProgress
                variant="determinate"
                value={completedTaskPercentage}
                size={64}
                thickness={5}
                aria-label="Progress"
                glow={settings[0].enableGlow}
              />

              <ProgressPercentageContainer
                glow={settings[0].enableGlow && completedTaskPercentage > 0}
              >
                <Typography
                  variant="caption"
                  component="div"
                  color="white"
                  sx={{ fontSize: "16px", fontWeight: 600 }}
                >{`${Math.round(completedTaskPercentage)}%`}</Typography>
              </ProgressPercentageContainer>
            </Box>
            <TaskCountTextContainer>
              <TaskCountHeader>
                {completedTasksCount === 0
                  ? `You have ${tasks.length} task${tasks.length > 1 ? "s" : ""} to complete.`
                  : `You've completed ${completedTasksCount} out of ${tasks.length} tasks.`}
              </TaskCountHeader>
              <TaskCompletionText>
                {getTaskCompletionText(completedTaskPercentage)}
              </TaskCompletionText>
              {tasksWithDeadlineTodayCount > 0 && (
                <span
                  style={{
                    opacity: 0.8,
                    display: "inline-block",
                  }}
                >
                  <TodayRounded sx={{ fontSize: "20px", verticalAlign: "middle" }} />
                  &nbsp;Tasks due today:&nbsp;
                  <span translate="no">
                    {new Intl.ListFormat("en", { style: "long" }).format(tasksDueTodayNames)}
                  </span>
                </span>
              )}
            </TaskCountTextContainer>
          </TasksCount>
        </TasksCountContainer>
      )}

      <Suspense fallback={<div>Loading...</div>}>
        <TaskProvider>
          <TasksList />
        </TaskProvider>
      </Suspense>

      {!isMobile && (
        <Tooltip title={tasks.length > 0 ? "Add New Task" : "Add Task"} placement="left">
          <AddButton
            animate={tasks.length === 0}
            glow={settings[0].enableGlow}
            onClick={() => n("add")}
            aria-label="Add Task"
          >
            <AddRounded style={{ fontSize: "44px" }} />
          </AddButton>
        </Tooltip>
      )}
    </>
  );
};

export default Home;


// File: workspace/TodoApp/src/pages/TaskDetails.tsx
import { useParams } from "react-router-dom";
import { CategoryBadge, TopBar } from "../components";
import styled from "@emotion/styled";
import { PathName } from "../styles";
import NotFound from "./NotFound";
import { Clear, Done } from "@mui/icons-material";
import { Emoji } from "emoji-picker-react";
import { useContext, useEffect } from "react";
import { UserContext } from "../contexts/UserContext";
import { getColorName } from "ntc-ts";

const TaskDetails = () => {
  const { user } = useContext(UserContext);
  const { tasks, emojisStyle } = user;
  const { id } = useParams();
  const formattedId = id?.replace(".", "");
  const task = tasks.find((task) => task.id.toString().replace(".", "") === formattedId);

  useEffect(() => {
    document.title = `Todo App - ${task?.name || "Task Details"}`;
  }, [task?.name]);

  if (!task) {
    return (
      <NotFound
        message={
          <div>
            Task with id <PathName>{formattedId}</PathName> was not found.
          </div>
        }
      />
    );
  }

  const dateFormatter = new Intl.DateTimeFormat(navigator.language, {
    dateStyle: "full",
    timeStyle: "short",
  });

  return (
    <>
      <TopBar title="Task Details" />
      <Container>
        <TaskName>
          Task: <span translate="no">{task.name}</span>
        </TaskName>
        <TaskTable>
          <tbody>
            <TableRow>
              <TableHeader>Emoji:</TableHeader>
              <TableData>
                {task.emoji ? (
                  <>
                    <Emoji unified={task?.emoji || ""} size={32} emojiStyle={emojisStyle} /> (
                    {task.emoji})
                  </>
                ) : (
                  <i>none</i>
                )}
              </TableData>
            </TableRow>
            <TableRow>
              <TableHeader>ID:</TableHeader>
              <TableData>{task?.id}</TableData>
            </TableRow>
            <TableRow>
              <TableHeader>Description:</TableHeader>
              <TableData translate="no">{task?.description}</TableData>
            </TableRow>
            <TableRow>
              <TableHeader>Color:</TableHeader>
              <TableData>
                <ColorSquare clr={task.color} />
                {getColorName(task.color).name} ({task.color.toUpperCase()})
              </TableData>
            </TableRow>
            <TableRow>
              <TableHeader>Created:</TableHeader>
              <TableData>{dateFormatter.format(new Date(task.date))}</TableData>
            </TableRow>
            {task?.lastSave && (
              <TableRow>
                <TableHeader>Last edited:</TableHeader>
                <TableData>{dateFormatter.format(new Date(task.lastSave))}</TableData>
              </TableRow>
            )}
            {task?.deadline && (
              <TableRow>
                <TableHeader>Task deadline:</TableHeader>
                <TableData>{dateFormatter.format(new Date(task.deadline))}</TableData>
              </TableRow>
            )}
            <TableRow>
              <TableHeader>Done:</TableHeader>
              <TableData>
                {task?.done ? <Done /> : <Clear />} {task?.done.toString()}
              </TableData>
            </TableRow>
            <TableRow>
              <TableHeader>Pinned:</TableHeader>
              <TableData>
                {task?.pinned ? <Done /> : <Clear />} {task?.pinned.toString()}
              </TableData>
            </TableRow>
            {task?.sharedBy && (
              <TableRow>
                <TableHeader>Shared by: </TableHeader>
                <TableData>{task.sharedBy}</TableData>
              </TableRow>
            )}
            {task.category && task.category.length > 0 && (
              <TableRow>
                <TableHeader>Categories:</TableHeader>
                <TableData>
                  <CategoryContainer>
                    {task?.category?.map((category) => (
                      <CategoryBadge key={category.id} category={category} glow={false} />
                    ))}
                  </CategoryContainer>
                </TableData>
              </TableRow>
            )}
          </tbody>
        </TaskTable>
      </Container>
    </>
  );
};

export default TaskDetails;

const Container = styled.div`
  display: flex;
  flex-direction: column;
  padding: 16px;
  border-radius: 32px;
  margin: 0 auto;
  margin-top: 100px;
  box-shadow: 0 0px 24px 2px rgba(0, 0, 0, 0.3);

  @media (min-width: 768px) {
    padding: 24px;
    width: 70%;
  }
`;

const TaskName = styled.h2`
  margin: 8px;
  text-align: center;
  font-size: 1.5em;

  @media (min-width: 768px) {
    font-size: 1.8em;
  }
`;

const TaskTable = styled.table`
  width: 100%;
  border-collapse: collapse;
  margin-top: 16px;
`;

const TableRow = styled.tr`
  border-bottom: 2px solid ${({ theme }) => theme.primary}41;

  &:last-child {
    border-bottom: none;
  }
`;

const TableHeader = styled.th`
  text-align: left;
  padding: 8px;
  font-size: 1em;

  @media (min-width: 768px) {
    font-size: 1.2em;
  }
`;

const TableData = styled.td`
  text-align: left;
  padding: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 1em;
  word-break: break-all;
  @media (min-width: 768px) {
    font-size: 1.1em;
  }
`;

const ColorSquare = styled.div<{ clr: string }>`
  width: 20px;
  height: 20px;
  border-radius: 6px;
  background-color: ${({ clr }) => clr};
`;

const CategoryContainer = styled.div`
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  gap: 6px;
`;


// File: workspace/TodoApp/src/pages/Share.tsx
import {
  Alert,
  AlertTitle,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Tooltip,
} from "@mui/material";
import {
  DescriptionLink,
  EmojiContainer,
  Pinned,
  RingAlarm,
  TaskContainer,
  TaskDate,
  TaskDescription,
  TaskHeader,
  TaskInfo,
  TaskName,
  TimeLeft,
} from "../components/tasks/tasks.styled";
import { DialogBtn } from "../styles";
import { useLocation, useNavigate } from "react-router-dom";
import { useContext, useEffect, useState } from "react";
import type { Task } from "../types/user";
import { calculateDateDifference, formatDate, getFontColor, showToast, systemInfo } from "../utils";
import { Emoji, EmojiStyle } from "emoji-picker-react";
import { UserContext } from "../contexts/UserContext";
import {
  AddTaskRounded,
  DoNotDisturbAltRounded,
  DoneRounded,
  LinkOff,
  PushPinRounded,
} from "@mui/icons-material";
import { URL_REGEX, USER_NAME_MAX_LENGTH } from "../constants";
import { CategoryBadge } from "../components";
import Home from "./Home";

//FIXME: make everything type-safe
const SharePage = () => {
  const { user, setUser } = useContext(UserContext);
  const n = useNavigate();
  const location = useLocation();
  const queryParams = new URLSearchParams(location.search);
  const taskParam = queryParams.get("task");
  const userNameParam = queryParams.get("userName");

  const [taskData, setTaskData] = useState<Task | null>(null);
  const [userName, setUserName] = useState<string>("");
  const [error, setError] = useState<boolean>(false);
  const [errorDetails, setErrorDetails] = useState<string | undefined>();
  const isHexColor = (value: string): boolean => /^#[0-9A-Fa-f]{6}$/.test(value);

  useEffect(() => {
    if (taskParam) {
      try {
        const decodedTask = decodeURIComponent(taskParam);
        const task: Task = {
          ...(JSON.parse(decodedTask) as Task),
          id: crypto.randomUUID(),
        };
        if (!isHexColor(task.color)) {
          setError(true);
          setErrorDetails("Invalid task color format.");
          return;
        }
        if (task.category) {
          task.category.forEach((taskCategory) => {
            if (!isHexColor(taskCategory.color)) {
              setError(true);
              setErrorDetails("Invalid category color format.");
              return;
            }
          });
        }
        setTaskData(task);
      } catch (error) {
        console.error("Error decoding task data:", error);
        setErrorDetails("Error decoding task data." + error);
        setError(true);
      }
    }

    if (userNameParam) {
      const decodedUserName = decodeURIComponent(userNameParam);
      if (decodedUserName.length > USER_NAME_MAX_LENGTH) {
        setError(true);
        setErrorDetails("User name is too long.");
      }
      setUserName(decodedUserName);
    }
  }, [taskParam, userNameParam]);

  useEffect(() => {
    document.title = `Todo App - Recieved Task ${taskData ? "(" + taskData.name + ")" : ""}`;
  }, [taskData]);

  const handleAddTask = () => {
    if (taskData) {
      // Add missing categories to user.categories
      const updatedCategories = [...user.categories];

      if (taskData.category) {
        taskData.category.forEach((taskCategory) => {
          const existingCategoryIndex = updatedCategories.findIndex(
            (cat) => cat.id === taskCategory.id
          );

          if (existingCategoryIndex !== -1) {
            // If category with the same ID exists, replace it with the new category
            updatedCategories[existingCategoryIndex] = taskCategory;
          } else {
            // Otherwise, add the new category to the array
            updatedCategories.push(taskCategory);
          }
        });
      }

      setUser((prevUser) => ({
        ...prevUser,
        categories: updatedCategories,
        tasks: [
          ...prevUser.tasks.filter(Boolean),
          {
            ...taskData,
            id: crypto.randomUUID(),
            sharedBy: userName,
          },
        ],
      }));

      n("/");
      showToast(
        <div>
          Added shared task - <b translate="no">{taskData.name}</b>
        </div>,
        {
          icon: <AddTaskRounded />,
        }
      );
    }
  };

  // Renders the task description with optional hyperlink parsing and text highlighting.
  const renderTaskDescription = (task: Task): JSX.Element | null => {
    if (!task || !task.description) {
      return null;
    }

    const { description, color } = task;

    const parts = description.split(URL_REGEX);

    const descriptionWithLinks = parts.map((part, index) => {
      if (index % 2 === 0) {
        return part;
      } else {
        // Store link part in state
        const url = new URL(part);
        return (
          <Tooltip title={part} key={index}>
            <DescriptionLink clr={color} disabled>
              <div>
                <LinkOff sx={{ fontSize: "24px" }} /> {url.hostname}
              </div>
            </DescriptionLink>
          </Tooltip>
        );
      }
    });

    return <div>{descriptionWithLinks}</div>;
  };

  return (
    <div>
      <Home />
      <Dialog
        open
        PaperProps={{
          style: {
            borderRadius: "24px",
            padding: " 10px 6px",
            width: "100% !important",
          },
        }}
      >
        {!error && taskData ? (
          <>
            <DialogTitle>Recieved Task</DialogTitle>
            <DialogContent>
              <p style={{ fontSize: "16px", marginLeft: "6px" }}>
                <b translate="no">{userName}</b> shared you a task.
              </p>
              <TaskContainer
                done={taskData.done}
                backgroundColor={taskData.color}
                style={{ maxWidth: "600px", opacity: 1, padding: "16px 22px" }}
              >
                {taskData.emoji || taskData.done ? (
                  <EmojiContainer clr={getFontColor(taskData.color)}>
                    {taskData.done ? (
                      <DoneRounded fontSize="large" />
                    ) : user.emojisStyle === EmojiStyle.NATIVE ? (
                      <div>
                        <Emoji
                          size={systemInfo.os === "iOS" ? 48 : 36}
                          unified={taskData.emoji || ""}
                          emojiStyle={EmojiStyle.NATIVE}
                        />
                      </div>
                    ) : (
                      <Emoji
                        size={48}
                        unified={taskData.emoji || ""}
                        emojiStyle={user.emojisStyle}
                      />
                    )}
                  </EmojiContainer>
                ) : null}
                <TaskInfo translate="no" style={{ marginRight: "14px" }}>
                  {taskData.pinned && (
                    <Pinned translate="yes">
                      <PushPinRounded fontSize="small" /> &nbsp; Pinned
                    </Pinned>
                  )}
                  <TaskHeader style={{ gap: "6px" }}>
                    <TaskName done={taskData.done}>{taskData.name}</TaskName>
                    <Tooltip
                      title={new Intl.DateTimeFormat(navigator.language, {
                        dateStyle: "full",
                        timeStyle: "medium",
                      }).format(new Date(taskData.date))}
                    >
                      <TaskDate>{formatDate(new Date(taskData.date))}</TaskDate>
                    </Tooltip>
                  </TaskHeader>
                  <TaskDescription done={taskData.done}>
                    {renderTaskDescription(taskData)}
                  </TaskDescription>
                  {taskData.deadline && (
                    <TimeLeft done={taskData.done}>
                      <RingAlarm
                        fontSize="small"
                        animate={new Date() > new Date(taskData.deadline) && !taskData.done}
                        sx={{
                          color: `${getFontColor(taskData.color)} !important`,
                        }}
                      />
                      &nbsp;Deadline:&nbsp;
                      {new Date(taskData.deadline).toLocaleDateString()} {" • "}
                      {new Date(taskData.deadline).toLocaleTimeString()}
                      {!taskData.done && (
                        <>
                          {" • "}
                          {calculateDateDifference(new Date(taskData.deadline))}
                        </>
                      )}
                    </TimeLeft>
                  )}
                  <div
                    style={{
                      display: "flex",
                      flexWrap: "wrap",
                      gap: "4px 6px",
                      justifyContent: "left",
                      alignItems: "center",
                    }}
                  >
                    {taskData.category &&
                      taskData.category.map((category) => (
                        <div key={category.id}>
                          <CategoryBadge
                            category={category}
                            borderclr={getFontColor(taskData.color)}
                          />
                        </div>
                      ))}
                  </div>
                </TaskInfo>
              </TaskContainer>
              {taskData && taskData.description && taskData.description.match(URL_REGEX) ? (
                <Alert sx={{ mt: "20px" }} severity="warning">
                  <AlertTitle>This task contains the following links:</AlertTitle>{" "}
                  {(() => {
                    const links = taskData.description.match(URL_REGEX)?.map((link) => link);
                    if (links) {
                      const listFormatter = new Intl.ListFormat("en-US", {
                        style: "long",
                        type: "conjunction",
                      });
                      return (
                        <span style={{ wordBreak: "break-all" }}>
                          {listFormatter.format(links)}
                        </span>
                      );
                    }
                    return null;
                  })()}
                </Alert>
              ) : null}
            </DialogContent>
            <DialogActions>
              <DialogBtn color="error" onClick={() => n("/")}>
                <DoNotDisturbAltRounded /> &nbsp; Decline
              </DialogBtn>
              <DialogBtn
                onClick={() => {
                  handleAddTask();
                  n("/");
                }}
              >
                <AddTaskRounded /> &nbsp; Add Task
              </DialogBtn>
            </DialogActions>
          </>
        ) : (
          <>
            <DialogTitle>Something went wrong</DialogTitle>
            <DialogContent>
              <p>
                Oops! Something went wrong while processing the shared task.{" "}
                {errorDetails && (
                  <b>
                    <br /> {errorDetails}
                  </b>
                )}
              </p>
            </DialogContent>
            <DialogActions>
              <DialogBtn onClick={() => n("/")}>Close</DialogBtn>
            </DialogActions>
          </>
        )}
      </Dialog>
    </div>
  );
};

export default SharePage;


// File: workspace/TodoApp/src/pages/ImportExport.tsx
import { useContext, useEffect, useRef, useState } from "react";
import Button from "@mui/material/Button";
import Checkbox from "@mui/material/Checkbox";
import { TopBar } from "../components";
import { Category, Task, UUID } from "../types/user";
import Typography from "@mui/material/Typography";
import { Emoji } from "emoji-picker-react";
import {
  FileDownload,
  FileUpload,
  IntegrationInstructionsRounded,
  Link,
} from "@mui/icons-material";
import { exportTasksToJson, showToast, systemInfo } from "../utils";
import { IconButton, Tooltip } from "@mui/material";
import {
  CATEGORY_NAME_MAX_LENGTH,
  DESCRIPTION_MAX_LENGTH,
  TASK_NAME_MAX_LENGTH,
} from "../constants";
import { UserContext } from "../contexts/UserContext";
import { useStorageState } from "../hooks/useStorageState";
import { useCtrlS } from "../hooks/useCtrlS";
import {
  DropZone,
  InfoIcon,
  ListContent,
  ManagementButton,
  ManagementButtonsContainer,
  ManagementContainer,
  ManagementHeader,
  TaskManagementContainer,
} from "../styles";

const ImportExport = () => {
  const { user, setUser } = useContext(UserContext);
  const [selectedTasks, setSelectedTasks] = useStorageState<UUID[]>(
    [],
    "tasksToExport",
    "sessionStorage"
  ); // Array of selected task IDs
  const [isDragging, setIsDragging] = useState<boolean>(false);
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  useCtrlS();

  useEffect(() => {
    document.title = "Todo App - Transfer tasks";
  }, []);

  // clear file input after logout
  useEffect(() => {
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  }, [user.createdAt]);

  const handleTaskClick = (taskId: UUID) => {
    setSelectedTasks((prevSelectedTasks) => {
      if (prevSelectedTasks.includes(taskId)) {
        return prevSelectedTasks.filter((id) => id !== taskId);
      } else {
        return [...prevSelectedTasks, taskId];
      }
    });
  };

  const handleExport = () => {
    const tasksToExport = user.tasks.filter((task) => selectedTasks.includes(task.id));
    exportTasksToJson(tasksToExport);
    showToast(
      <div>
        Exported tasks:{" "}
        <ul>
          {tasksToExport.map((task) => (
            <li key={task.id}>
              <ListContent>
                <Emoji unified={task.emoji || ""} size={20} emojiStyle={user.emojisStyle} />
                <span translate="no">{task.name}</span>
              </ListContent>
            </li>
          ))}
        </ul>
      </div>,
      { dismissButton: true, type: "blank" }
    );
  };

  const handleExportAll = () => {
    exportTasksToJson(user.tasks);
    showToast(`Exported all tasks (${user.tasks.length})`);
  };

  const handleImport = (taskFile: File) => {
    const file = taskFile;

    if (file) {
      if (file.type !== "application/json") {
        showToast(
          <div>
            Incorrect file type {file.type !== "" && <span translate="no">{file.type}</span>}.
            Please select a JSON file.
          </div>,
          { type: "error" }
        );
        return;
      }

      const reader = new FileReader();

      reader.onload = (e: ProgressEvent<FileReader>) => {
        try {
          const importedTasks = JSON.parse(e.target?.result as string) as Task[];

          if (!Array.isArray(importedTasks)) {
            showToast("Imported file has an invalid structure.", { type: "error" });
            return;
          }

          /**
           * TODO: write separate util function to check if task is not invalid
           */

          // Check if any imported task property exceeds the maximum length
          const invalidTasks = importedTasks.filter((task) => {
            const isInvalid =
              (task.name && task.name.length > TASK_NAME_MAX_LENGTH) ||
              (task.description && task.description.length > DESCRIPTION_MAX_LENGTH) ||
              (task.category &&
                task.category.some((cat) => cat.name.length > CATEGORY_NAME_MAX_LENGTH));

            return isInvalid;
          });

          if (invalidTasks.length > 0) {
            const invalidTaskNames = invalidTasks.map((task) => task.name).join(", ");
            console.error(
              `These tasks cannot be imported due to exceeding maximum character lengths: ${invalidTaskNames}`
            );
            showToast(
              `These tasks cannot be imported due to exceeding maximum character lengths: ${invalidTaskNames}`,
              { type: "error" }
            );
            return;
          }

          const isHexColor = (value: string): boolean => /^#[0-9A-Fa-f]{6}$/.test(value);

          const isCategoryColorValid = (category: Category) =>
            category.color && isHexColor(category.color);

          const hasInvalidColors = importedTasks.some((task) => {
            return (
              (task.color && !isHexColor(task.color)) ||
              (task.category && !task.category.every((cat) => isCategoryColorValid(cat)))
            );
          });

          if (hasInvalidColors) {
            showToast("Imported file contains tasks with invalid color formats.", {
              type: "error",
            });
            return;
          }

          const maxFileSize = 50_000;
          if (file.size > maxFileSize) {
            showToast(`File size is too large (${file.size}/${maxFileSize})`, { type: "error" });
            return;
          }

          // Update user.categories if imported categories don't exist
          const updatedCategories = user.categories.slice(); // Create a copy of the existing categories

          importedTasks.forEach((task) => {
            task.category !== undefined &&
              task.category.forEach((importedCat) => {
                const existingCategory = updatedCategories.find((cat) => cat.id === importedCat.id);

                if (!existingCategory) {
                  updatedCategories.push(importedCat);
                } else {
                  // Replace the existing category with the imported one if the ID matches
                  Object.assign(existingCategory, importedCat);
                }
              });
          });

          setUser((prevUser) => ({
            ...prevUser,
            categories: updatedCategories,
          }));

          const mergedTasks = [...user.tasks, ...importedTasks];
          const uniqueTasks = mergedTasks.reduce((acc, task) => {
            const existingTask = acc.find((t) => t.id === task.id);
            if (existingTask) {
              return acc.map((t) => (t.id === task.id ? task : t));
            } else {
              return [...acc, task];
            }
          }, [] as Task[]);

          setUser((prevUser) => ({ ...prevUser, tasks: uniqueTasks }));

          // Prepare the list of imported task names
          const importedTaskNames = importedTasks.map((task) => task.name).join(", ");

          // Display the alert with the list of imported task names
          console.log(`Imported Tasks: ${importedTaskNames}`);

          showToast(
            <div>
              Tasks Successfully Imported from <br />
              <i translate="no" style={{ wordBreak: "break-all" }}>
                {file.name}
              </i>
              <ul>
                {importedTasks.map((task) => (
                  <li key={task.id}>
                    <ListContent>
                      <Emoji unified={task.emoji || ""} size={20} emojiStyle={user.emojisStyle} />
                      <span translate="no">{task.name}</span>
                    </ListContent>
                  </li>
                ))}
              </ul>
            </div>,
            { dismissButton: true, type: "blank" }
          );

          if (fileInputRef.current) {
            fileInputRef.current.value = "";
          }
        } catch (error) {
          console.error(`Error parsing the imported file ${file.name}:`, error);
          showToast(
            <div style={{ wordBreak: "break-all" }}>
              Error parsing the imported file: <br /> <i>{file.name}</i>
            </div>,
            { type: "error" }
          );
          if (fileInputRef.current) {
            fileInputRef.current.value = "";
          }
        }
      };

      reader.readAsText(file);
    }
  };

  const handleImportFromLink = async (): Promise<void> => {
    try {
      const text = await navigator.clipboard.readText();
      if (text.startsWith(`${location.protocol}//${location.hostname}`)) {
        window.open(text, "_self");
      } else {
        showToast(
          <div>
            Failed to import task from the provided link. Please ensure that the link is copied
            correctly.
          </div>,
          { type: "error" }
        );
      }
    } catch (err) {
      console.error("Failed to read clipboard contents: ", err);
    }
  };

  const handleImportFromClipboard = async (): Promise<void> => {
    try {
      const text = await navigator.clipboard.readText();
      const file = new File([text], "Clipboard", { type: "application/json" });
      handleImport(file);
    } catch (err) {
      console.error("Failed to read clipboard contents: ", err);
    }
  };

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = "copy";
    setIsDragging(true);
  };

  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    setIsDragging(false);

    const file = e.dataTransfer.files[0];
    console.log(file);
    if (file.size === 0 || file.type === "") {
      showToast(
        <div>
          Unknown file type{" "}
          <i translate="no" style={{ wordBreak: "break-all" }}>
            {file.name}
          </i>
        </div>,
        { type: "error" }
      );
      return;
    }
    handleImport(file);
  };

  const handleSelectChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files && e.target.files[0];
    file && handleImport(file);
  };

  return (
    <>
      <TopBar title="Transfer Tasks" />
      <ManagementHeader>
        Select Tasks To Export&nbsp;
        <Tooltip title="Duplicates will be removed during import">
          <IconButton style={{ color: "#ffffff" }}>
            <InfoIcon />
          </IconButton>
        </Tooltip>
      </ManagementHeader>

      <ManagementContainer>
        {user.tasks.length > 0 ? (
          user.tasks.map((task: Task) => (
            <TaskManagementContainer
              key={task.id}
              backgroundClr={task.color}
              onClick={() => handleTaskClick(task.id)}
              selected={selectedTasks.includes(task.id)}
              translate="no"
            >
              <Checkbox color="primary" size="medium" checked={selectedTasks.includes(task.id)} />
              <Typography
                variant="body1"
                component="span"
                sx={{ display: "flex", alignItems: "center", gap: "6px", wordBreak: "break-word" }}
              >
                <Emoji size={24} unified={task.emoji || ""} emojiStyle={user.emojisStyle} />{" "}
                {task.name}
              </Typography>
            </TaskManagementContainer>
          ))
        ) : (
          <h3 style={{ opacity: 0.8, fontStyle: "italic" }}>You don't have any tasks to export</h3>
        )}
      </ManagementContainer>

      <ManagementButtonsContainer>
        <Tooltip
          title={
            selectedTasks.length > 0
              ? `Selected tasks: ${new Intl.ListFormat("en", {
                  style: "long",
                  type: "conjunction",
                }).format(
                  selectedTasks.map((taskId) => {
                    const selectedTask = user.tasks.find((task) => task.id === taskId);
                    return selectedTask ? selectedTask.name : "";
                  })
                )}`
              : undefined
          }
        >
          <ManagementButton onClick={handleExport} disabled={selectedTasks.length === 0}>
            <FileDownload /> &nbsp; Export Selected to JSON{" "}
            {selectedTasks.length > 0 && `[${selectedTasks.length}]`}
          </ManagementButton>
        </Tooltip>
        <ManagementButton onClick={handleExportAll} disabled={user.tasks.length === 0}>
          <FileDownload /> &nbsp; Export All Tasks to JSON
        </ManagementButton>

        <h2 style={{ textAlign: "center" }}>Import Tasks From JSON</h2>

        {systemInfo.os !== "Android" && systemInfo.os !== "iOS" && (
          <div style={{ width: "300px" }}>
            <DropZone
              onDragOver={handleDragOver}
              onDragLeave={() => setIsDragging(false)}
              onDrop={handleDrop}
              isDragging={isDragging}
            >
              <FileUpload fontSize="large" color="primary" />
              <div>Drop JSON file here to import tasks </div>
            </DropZone>
          </div>
        )}

        <input
          accept=".json"
          id="import-file"
          type="file"
          ref={fileInputRef}
          style={{ display: "none" }}
          onChange={handleSelectChange}
        />
        <label htmlFor="import-file">
          <Button
            component="span"
            variant="outlined"
            sx={{
              p: "12px 20px",
              borderRadius: "14px",
              width: "300px",
            }}
          >
            <FileUpload /> &nbsp; Select JSON File
          </Button>
        </label>

        <ManagementButton onClick={handleImportFromClipboard}>
          <IntegrationInstructionsRounded /> &nbsp; Import JSON from clipboard
        </ManagementButton>

        {/* Solution for PWA on iOS: */}
        <ManagementButton onClick={handleImportFromLink}>
          <Link /> &nbsp; Import From Link
        </ManagementButton>
      </ManagementButtonsContainer>
    </>
  );
};

export default ImportExport;


// File: workspace/TodoApp/src/pages/NotFound.tsx
import styled from "@emotion/styled";
import { ArrowBackIosNew } from "@mui/icons-material";
import { Button } from "@mui/material";
import { useNavigate } from "react-router-dom";
import { PathName } from "../styles";
import { ReactNode, useEffect } from "react";
import { TaskIcon } from "../components";

interface NotFoundProps {
  message?: string | ReactNode;
}

const NotFound: React.FC<NotFoundProps> = ({ message }) => {
  const n = useNavigate();

  useEffect(() => {
    document.title = "Todo App - Page Not Found";
  }, []);

  return (
    <Container>
      <ErrorCode>404</ErrorCode>
      <TaskIcon scale={0.9} />
      <Description>
        {message || (
          <div>
            Page{" "}
            <PathName>
              {location.pathname.length > 32
                ? location.pathname.substring(0, 29) + "..."
                : location.pathname}
            </PathName>{" "}
            was not found.
          </div>
        )}
      </Description>
      <BackButton variant="outlined" onClick={() => n("/")}>
        <ArrowBackIosNew /> &nbsp; Go back to tasks
      </BackButton>
    </Container>
  );
};
export default NotFound;

const Container = styled.div`
  text-align: center;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  min-width: 100vw;
  line-height: 2em;
`;

const ErrorCode = styled.h1`
  font-size: 128px;
  color: ${({ theme }) => theme.primary};
  text-shadow: 0 0 32px ${({ theme }) => theme.primary + "a9"};
  margin: 48px 0;
`;

const Description = styled.p`
  font-size: 22px;
  line-height: 1.8em;
  margin: 32px;
`;

const BackButton = styled(Button)`
  padding: 12px 20px;
  font-size: 18px;
  border-radius: 16px;
  margin: 16px;
`;


// File: workspace/TodoApp/src/pages/AddTask.tsx
import { Category, Task } from "../types/user";
import { useState, useEffect, useContext } from "react";
import { Link, useNavigate } from "react-router-dom";
import { AddTaskButton, Container, StyledInput } from "../styles";
import { AddTaskRounded, CancelRounded, Edit } from "@mui/icons-material";
import { Button, IconButton, InputAdornment, Tooltip } from "@mui/material";
import { DESCRIPTION_MAX_LENGTH, TASK_NAME_MAX_LENGTH } from "../constants";
import { CategorySelect, ColorPicker, TopBar, CustomEmojiPicker } from "../components";
import { UserContext } from "../contexts/UserContext";
import { useStorageState } from "../hooks/useStorageState";
import { useTheme } from "@emotion/react";
import { getFontColor, showToast } from "../utils";
import { ColorPalette } from "../theme/themeConfig";

const AddTask = () => {
  const { user, setUser } = useContext(UserContext);
  const theme = useTheme();
  const [name, setName] = useStorageState<string>("", "name", "sessionStorage");
  const [emoji, setEmoji] = useStorageState<string | null>(null, "emoji", "sessionStorage");
  const [color, setColor] = useStorageState<string>(theme.primary, "color", "sessionStorage");
  const [description, setDescription] = useStorageState<string>(
    "",
    "description",
    "sessionStorage"
  );
  const [deadline, setDeadline] = useStorageState<string>("", "deadline", "sessionStorage");
  const [nameError, setNameError] = useState<string>("");
  const [descriptionError, setDescriptionError] = useState<string>("");
  const [selectedCategories, setSelectedCategories] = useStorageState<Category[]>(
    [],
    "categories",
    "sessionStorage"
  );

  const n = useNavigate();

  useEffect(() => {
    document.title = "Todo App - Add Task";
  }, []);

  useEffect(() => {
    if (name.length > TASK_NAME_MAX_LENGTH) {
      setNameError(`Name should be less than or equal to ${TASK_NAME_MAX_LENGTH} characters`);
    } else {
      setNameError("");
    }
    if (description.length > DESCRIPTION_MAX_LENGTH) {
      setDescriptionError(
        `Description should be less than or equal to ${DESCRIPTION_MAX_LENGTH} characters`
      );
    } else {
      setDescriptionError("");
    }
  }, [description.length, name.length]);

  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newName = event.target.value;
    setName(newName);
    if (newName.length > TASK_NAME_MAX_LENGTH) {
      setNameError(`Name should be less than or equal to ${TASK_NAME_MAX_LENGTH} characters`);
    } else {
      setNameError("");
    }
  };

  const handleDescriptionChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newDescription = event.target.value;
    setDescription(newDescription);
    if (newDescription.length > DESCRIPTION_MAX_LENGTH) {
      setDescriptionError(
        `Description should be less than or equal to ${DESCRIPTION_MAX_LENGTH} characters`
      );
    } else {
      setDescriptionError("");
    }
  };

  const handleDeadlineChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setDeadline(event.target.value);
  };

  const handleAddTask = () => {
    if (name === "") {
      showToast("Task name is required.", { type: "error" });
      return;
    }

    if (nameError !== "" || descriptionError !== "") {
      return; // Do not add the task if the name or description exceeds the maximum length
    }

    const newTask: Task = {
      id: crypto.randomUUID(),
      done: false,
      pinned: false,
      name,
      description: description !== "" ? description : undefined,
      emoji: emoji ? emoji : undefined,
      color,
      date: new Date(),
      deadline: deadline !== "" ? new Date(deadline) : undefined,
      category: selectedCategories ? selectedCategories : [],
    };

    setUser((prevUser) => ({
      ...prevUser,
      tasks: [...prevUser.tasks, newTask],
    }));

    n("/");

    showToast(
      <div>
        Added task - <b>{newTask.name}</b>
      </div>,
      {
        icon: <AddTaskRounded />,
      }
    );

    const itemsToRemove = ["name", "color", "description", "emoji", "deadline", "categories"];
    itemsToRemove.map((item) => sessionStorage.removeItem(item));
  };

  return (
    <>
      <TopBar title="Add New Task" />
      <Container>
        <CustomEmojiPicker
          emoji={typeof emoji === "string" ? emoji : undefined}
          setEmoji={setEmoji}
          color={color}
          name={name}
        />
        <StyledInput
          label="Task Name"
          name="name"
          placeholder="Enter task name"
          autoComplete="off"
          value={name}
          onChange={handleNameChange}
          focused
          required
          error={nameError !== ""}
          helpercolor={nameError && ColorPalette.red}
          helperText={
            name === ""
              ? undefined
              : !nameError
              ? `${name.length}/${TASK_NAME_MAX_LENGTH}`
              : nameError
          }
        />
        <StyledInput
          label="Task Description (optional)"
          name="name"
          placeholder="Enter task description"
          autoComplete="off"
          value={description}
          onChange={handleDescriptionChange}
          multiline
          rows={4}
          focused
          error={descriptionError !== ""}
          helpercolor={descriptionError && ColorPalette.red}
          helperText={
            description === ""
              ? undefined
              : !descriptionError
              ? `${description.length}/${DESCRIPTION_MAX_LENGTH}`
              : descriptionError
          }
        />
        <StyledInput
          label="Task Deadline (optional)"
          name="name"
          placeholder="Enter deadline date"
          type="datetime-local"
          value={deadline}
          onChange={handleDeadlineChange}
          defaultValue=""
          focused
          sx={{
            colorScheme: getFontColor(theme.secondary) === ColorPalette.fontDark ? "light" : "dark",
          }}
          InputProps={{
            startAdornment:
              deadline && deadline !== "" ? (
                <InputAdornment position="start">
                  <Tooltip title="Clear">
                    <IconButton color="error" onClick={() => setDeadline("")}>
                      <CancelRounded />
                    </IconButton>
                  </Tooltip>
                </InputAdornment>
              ) : undefined,
          }}
        />
        {user.settings[0].enableCategories !== undefined && user.settings[0].enableCategories && (
          <>
            <br />
            <CategorySelect
              selectedCategories={selectedCategories}
              onCategoryChange={(categories) => setSelectedCategories(categories)}
              width="400px"
              fontColor={getFontColor(theme.secondary)}
            />
            <Link to="/categories">
              <Button
                sx={{
                  margin: "8px 0 24px 0 ",
                  p: "12px 20px",
                  borderRadius: "14px",
                }}
              >
                <Edit /> &nbsp; Modify Categories
              </Button>
            </Link>
          </>
        )}
        <ColorPicker
          color={color}
          width="400px"
          onColorChange={(color) => {
            setColor(color);
          }}
          fontColor={getFontColor(theme.secondary)}
        />
        <AddTaskButton
          onClick={handleAddTask}
          disabled={
            name.length > TASK_NAME_MAX_LENGTH || description.length > DESCRIPTION_MAX_LENGTH
          }
        >
          Create Task
        </AddTaskButton>
      </Container>
    </>
  );
};

export default AddTask;


// File: workspace/TodoApp/src/pages/Purge.tsx
import { useContext, useEffect, useState } from "react";
import { TopBar } from "../components";
import {
  DialogBtn,
  ManagementButton,
  ManagementButtonsContainer,
  ManagementContainer,
  ManagementHeader,
  TaskManagementContainer,
} from "../styles";
import { UserContext } from "../contexts/UserContext";
import {
  Checkbox,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Divider,
  Tooltip,
  Typography,
} from "@mui/material";
import { Emoji } from "emoji-picker-react";
import { Task, UUID } from "../types/user";
import { useStorageState } from "../hooks/useStorageState";
import { DeleteForeverRounded, DeleteSweepRounded, DoneAllRounded } from "@mui/icons-material";
import { showToast } from "../utils";

const Purge = () => {
  const { user, setUser } = useContext(UserContext);
  const { tasks } = user;

  const [selectedTasks, setSelectedTasks] = useStorageState<UUID[]>(
    [],
    "tasksToPurge",
    "sessionStorage"
  ); // Array of selected task IDs
  const [deleteAllDialog, setDeleteAllDialog] = useState<boolean>(false);

  useEffect(() => {
    document.title = "Todo App - Purge tasks";
  }, []);

  const doneTasks = tasks.filter((task) => task.done);
  const notDoneTasks = tasks.filter((task) => !task.done);

  const selectedNamesList = new Intl.ListFormat("en", {
    style: "long",
    type: "conjunction",
  }).format(
    selectedTasks.map((taskId) => {
      const selectedTask = user.tasks.find((task) => task.id === taskId);
      return selectedTask ? selectedTask.name : "";
    })
  );

  const handleTaskClick = (taskId: UUID) => {
    setSelectedTasks((prevSelectedTasks) => {
      if (prevSelectedTasks.includes(taskId)) {
        return prevSelectedTasks.filter((id) => id !== taskId);
      } else {
        return [...prevSelectedTasks, taskId];
      }
    });
  };

  const purgeTasks = (tasks: Task[]) => {
    const updatedTasks = user.tasks.filter(
      (task) => !tasks.some((purgeTask) => purgeTask === task)
    );
    setSelectedTasks([]);
    setUser((prevUser) => ({
      ...prevUser,
      tasks: updatedTasks,
    }));
  };

  const handlePurgeSelected = () => {
    const tasksToPurge = tasks.filter((task: Task) => selectedTasks.includes(task.id));
    purgeTasks(tasksToPurge);
    showToast(
      <div>
        Purged selectedTasks tasks: <b translate="no">{selectedNamesList}</b>
      </div>
    );
  };

  const handlePurgeDone = () => {
    purgeTasks(doneTasks);
    showToast("Purged all done tasks.");
  };

  const handlePurgeAll = () => {
    setDeleteAllDialog(true);
  };

  const renderTasks = (tasks: Task[], title: string) => {
    return (
      <>
        <Divider sx={{ fontWeight: 500, my: "4px" }}>{title}</Divider>
        {tasks.map((task) => (
          <TaskManagementContainer
            key={task.id}
            backgroundClr={task.color}
            onClick={() => handleTaskClick(task.id)}
            selected={selectedTasks.includes(task.id)}
            translate="no"
          >
            <Checkbox size="medium" checked={selectedTasks.includes(task.id)} />
            <Typography
              variant="body1"
              component="span"
              sx={{
                display: "flex",
                alignItems: "center",
                gap: "6px",
                wordBreak: "break-word",
              }}
            >
              <Emoji size={24} unified={task.emoji || ""} emojiStyle={user.emojisStyle} />{" "}
              {task.name}
            </Typography>
          </TaskManagementContainer>
        ))}
      </>
    );
  };

  return (
    <>
      <TopBar title="Purge Tasks" />
      <ManagementHeader>Select Tasks To Purge</ManagementHeader>
      <ManagementContainer>
        {doneTasks.length > 0 && renderTasks(doneTasks, "Done Tasks")}
        {notDoneTasks.length > 0 && renderTasks(notDoneTasks, "Not Done Tasks")}
        {tasks.length === 0 && (
          <h3 style={{ opacity: 0.8, fontStyle: "italic" }}>You don't have any tasks to purge</h3>
        )}
      </ManagementContainer>
      <ManagementButtonsContainer>
        <Tooltip
          title={
            selectedTasks.length > 0 ? (
              <div>
                <span>Selected Tasks: </span>
                <span translate="no">{selectedNamesList}</span>
              </div>
            ) : undefined
          }
        >
          <ManagementButton onClick={handlePurgeSelected} disabled={selectedTasks.length === 0}>
            <DeleteSweepRounded /> &nbsp; Purge Selected{" "}
            {selectedTasks.length > 0 && `[${selectedTasks.length}]`}
          </ManagementButton>
        </Tooltip>
        <ManagementButton onClick={handlePurgeDone} disabled={doneTasks.length === 0}>
          <DoneAllRounded /> &nbsp; Purge Done
        </ManagementButton>
        <ManagementButton color="error" onClick={handlePurgeAll} disabled={tasks.length === 0}>
          <DeleteForeverRounded /> &nbsp; Purge All Tasks
        </ManagementButton>
      </ManagementButtonsContainer>
      <Dialog open={deleteAllDialog} onClose={() => setDeleteAllDialog(false)}>
        <DialogTitle>Are You sure you want to pure all of your tasks?</DialogTitle>
        <DialogContent>
          This action cannot be undone. Are you sure you want to proceed?
        </DialogContent>
        <DialogActions>
          <DialogBtn onClick={() => setDeleteAllDialog(false)}>Cancel</DialogBtn>
          <DialogBtn
            color="error"
            onClick={() => {
              purgeTasks(tasks);
              setDeleteAllDialog(false);
              showToast("Purged all tasks");
            }}
          >
            <DeleteForeverRounded /> &nbsp; Purge
          </DialogBtn>
        </DialogActions>
      </Dialog>
    </>
  );
};

export default Purge;


// File: workspace/TodoApp/src/pages/Categories.tsx
import { Emoji } from "emoji-picker-react";
import { lazy, useContext, useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import { ColorPicker, CustomEmojiPicker, TopBar } from "../components";
import type { Category, UUID } from "../types/user";
import { useTheme } from "@emotion/react";
import { Delete, DeleteRounded, Edit, SaveRounded } from "@mui/icons-material";
import {
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  IconButton,
  Tooltip,
} from "@mui/material";
import { CATEGORY_NAME_MAX_LENGTH } from "../constants";
import { UserContext } from "../contexts/UserContext";
import { useStorageState } from "../hooks/useStorageState";
import {
  ActionButton,
  AddCategoryButton,
  AddContainer,
  CategoriesContainer,
  CategoryContent,
  CategoryElement,
  CategoryElementsContainer,
  CategoryInput,
  DialogBtn,
  EditNameInput,
} from "../styles";
import { getFontColor, showToast } from "../utils";
import { ColorPalette } from "../theme/themeConfig";

const NotFound = lazy(() => import("./NotFound"));

const Categories = () => {
  const { user, setUser } = useContext(UserContext);
  const theme = useTheme();

  const [name, setName] = useStorageState<string>("", "catName", "sessionStorage");
  const [nameError, setNameError] = useState<string>("");
  const [emoji, setEmoji] = useStorageState<string | null>(null, "catEmoji", "sessionStorage");
  const [color, setColor] = useStorageState<string>(theme.primary, "catColor", "sessionStorage");

  const [openDeleteDialog, setOpenDeleteDialog] = useState<boolean>(false);
  const [selectedCategoryId, setSelectedCategoryId] = useState<UUID | undefined>();

  const [openEditDialog, setOpenEditDialog] = useState<boolean>(false);
  const [editName, setEditName] = useState<string>("");
  const [editNameError, setEditNameError] = useState<string>("");
  const [editEmoji, setEditEmoji] = useState<string | undefined>();
  const [editColor, setEditColor] = useState<string>(ColorPalette.purple);

  const n = useNavigate();

  useEffect(() => {
    document.title = "Todo App - Categories";
    if (!user.settings[0].enableCategories) {
      n("/");
    }
    if (name.length > CATEGORY_NAME_MAX_LENGTH) {
      setNameError(`Name is too long maximum ${CATEGORY_NAME_MAX_LENGTH} characters`);
    }
  }, [n, name.length, user.settings]);

  useEffect(() => {
    setEditColor(
      user.categories.find((cat) => cat.id === selectedCategoryId)?.color || ColorPalette.purple
    );
    setEditName(user.categories.find((cat) => cat.id === selectedCategoryId)?.name || "");
    setEditNameError("");
  }, [selectedCategoryId, user.categories]);

  const handleDelete = (categoryId: UUID | undefined) => {
    if (categoryId) {
      const categoryName =
        user.categories.find((category) => category.id === categoryId)?.name || "";
      const updatedCategories = user.categories.filter((category) => category.id !== categoryId);
      // Remove the category from tasks that have it associated
      const updatedTasks = user.tasks.map((task) => {
        const updatedCategoryList = task.category?.filter((category) => category.id !== categoryId);
        return {
          ...task,
          category: updatedCategoryList,
        };
      });

      setUser({
        ...user,
        categories: updatedCategories,
        tasks: updatedTasks,
      });

      showToast(
        <div>
          Deleted category - <b translate="no">{categoryName}.</b>
        </div>
      );
    }
  };

  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newName = event.target.value;
    setName(newName);
    if (newName.length > CATEGORY_NAME_MAX_LENGTH) {
      setNameError(`Name is too long (maximum ${CATEGORY_NAME_MAX_LENGTH} characters)`);
    } else {
      setNameError("");
    }
  };

  const handleEditNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newName = event.target.value;
    setEditName(newName);
    if (newName.length > CATEGORY_NAME_MAX_LENGTH) {
      setEditNameError(`Name is too long (maximum ${CATEGORY_NAME_MAX_LENGTH} characters)`);
    } else {
      setEditNameError("");
    }
  };

  const handleAddCategory = () => {
    if (name !== "") {
      if (name.length > CATEGORY_NAME_MAX_LENGTH) {
        return;
      }
      const newCategory: Category = {
        id: crypto.randomUUID(),
        name,
        emoji: emoji !== "" && emoji !== null ? emoji : undefined,
        color,
      };

      showToast(
        <div>
          Added category - <b translate="no">{newCategory.name}</b>
        </div>
      );

      setUser((prevUser) => ({
        ...prevUser,
        categories: [...prevUser.categories, newCategory],
      }));

      setName("");
      setColor(theme.primary);
      setEmoji("");
    } else {
      showToast("Category name is required.", { type: "error" });
    }
  };

  const handleEditDimiss = () => {
    setSelectedCategoryId(undefined);
    setOpenEditDialog(false);
    setEditColor(theme.primary);
    setEditName("");
    setEditEmoji(undefined);
  };

  const handleEditCategory = () => {
    if (selectedCategoryId) {
      const updatedCategories = user.categories.map((category) => {
        if (category.id === selectedCategoryId) {
          return {
            ...category,
            name: editName,
            emoji: editEmoji || undefined,
            color: editColor,
          };
        }
        return category;
      });

      const updatedTasks = user.tasks.map((task) => {
        const updatedCategoryList = task.category?.map((category) => {
          if (category.id === selectedCategoryId) {
            return {
              id: selectedCategoryId,
              name: editName,
              emoji: editEmoji || undefined,
              color: editColor,
            };
          }
          return category;
        });

        return {
          ...task,
          category: updatedCategoryList,
        };
      });

      setUser({
        ...user,
        categories: updatedCategories,
        tasks: updatedTasks,
      });

      showToast(
        <div>
          Updated category - <b translate="no">{editName}</b>
        </div>
      );

      setOpenEditDialog(false);
    }
  };

  if (!user.settings[0].enableCategories) {
    return <NotFound message="Categories are not enabled." />;
  }

  return (
    <>
      <TopBar title="Categories" />
      <CategoriesContainer>
        {user.categories.length > 0 ? (
          <CategoryElementsContainer>
            {user.categories.map((category) => {
              const categoryTasks = user.tasks.filter((task) =>
                task.category?.some((cat) => cat.id === category.id)
              );

              const completedTasksCount = categoryTasks.reduce(
                (count, task) => (task.done ? count + 1 : count),
                0
              );
              const totalTasksCount = categoryTasks.length;
              const completionPercentage =
                totalTasksCount > 0 ? Math.floor((completedTasksCount / totalTasksCount) * 100) : 0;

              const displayPercentage = totalTasksCount > 0 ? `(${completionPercentage}%)` : "";

              return (
                <CategoryElement key={category.id} clr={category.color}>
                  <CategoryContent translate="no">
                    <span>
                      {category.emoji && (
                        <Emoji unified={category.emoji} emojiStyle={user.emojisStyle} />
                      )}
                    </span>
                    &nbsp;
                    <span style={{ wordBreak: "break-all", fontWeight: 600 }}>{category.name}</span>
                    {totalTasksCount > 0 && (
                      <Tooltip title="The percentage of completion of tasks assigned to this category">
                        <span style={{ opacity: 0.8, fontStyle: "italic" }}>
                          {displayPercentage}
                        </span>
                      </Tooltip>
                    )}
                  </CategoryContent>
                  <div style={{ display: "flex", gap: "4px" }}>
                    <ActionButton>
                      <IconButton
                        color="primary"
                        onClick={() => {
                          setSelectedCategoryId(category.id);
                          setOpenEditDialog(true);
                        }}
                      >
                        <Edit />
                      </IconButton>
                    </ActionButton>
                    <ActionButton>
                      <IconButton
                        color="error"
                        onClick={() => {
                          setSelectedCategoryId(category.id);
                          if (totalTasksCount > 0) {
                            // Open delete dialog if there are tasks associated to catagory
                            setOpenDeleteDialog(true);
                          } else {
                            // If no associated tasks, directly handle deletion
                            handleDelete(category.id);
                          }
                        }}
                      >
                        <Delete />
                      </IconButton>
                    </ActionButton>
                  </div>
                </CategoryElement>
              );
            })}
          </CategoryElementsContainer>
        ) : (
          <p>You don't have any categories</p>
        )}
        <AddContainer>
          <h2>Add New Category</h2>
          <CustomEmojiPicker
            emoji={typeof emoji === "string" ? emoji : undefined}
            setEmoji={setEmoji}
            color={color}
          />
          <CategoryInput
            focused
            required
            label="Category name"
            placeholder="Enter category name"
            value={name}
            onChange={handleNameChange}
            error={nameError !== ""}
            helperText={
              name == ""
                ? undefined
                : !nameError
                ? `${name.length}/${CATEGORY_NAME_MAX_LENGTH}`
                : nameError
            }
          />
          {/* <Typography>Color</Typography> */}
          <ColorPicker
            color={color}
            onColorChange={(color) => {
              setColor(color);
            }}
            width={360}
            fontColor={getFontColor(theme.secondary)}
          />
          <AddCategoryButton
            onClick={handleAddCategory}
            disabled={name.length > CATEGORY_NAME_MAX_LENGTH}
          >
            Create Category
          </AddCategoryButton>
        </AddContainer>
        <Dialog
          open={openDeleteDialog}
          onClose={() => setOpenDeleteDialog(false)}
          PaperProps={{
            style: {
              borderRadius: "24px",
              padding: "12px",
              maxWidth: "600px",
            },
          }}
        >
          <DialogTitle>
            Confirm deletion of{" "}
            <b>{user.categories.find((cat) => cat.id === selectedCategoryId)?.name}</b>
          </DialogTitle>

          <DialogContent>
            This will remove the category from your list and associated tasks.
          </DialogContent>

          <DialogActions>
            <DialogBtn onClick={() => setOpenDeleteDialog(false)}>Cancel</DialogBtn>
            <DialogBtn
              onClick={() => {
                handleDelete(selectedCategoryId);
                setOpenDeleteDialog(false);
              }}
              color="error"
            >
              <DeleteRounded /> &nbsp; Delete
            </DialogBtn>
          </DialogActions>
        </Dialog>
        {/* Edit Dialog */}
        <Dialog
          open={openEditDialog}
          onClose={handleEditDimiss}
          PaperProps={{
            style: {
              borderRadius: "24px",
              padding: "12px",
              maxWidth: "600px",
            },
          }}
        >
          <DialogTitle>
            Edit Category
            {/* <b>{user.categories.find((cat) => cat.id === selectedCategoryId)?.name}</b> */}
          </DialogTitle>

          <DialogContent>
            <CustomEmojiPicker
              emoji={
                user.categories.find((cat) => cat.id === selectedCategoryId)?.emoji || undefined
              }
              setEmoji={setEditEmoji}
              width={300}
              color={editColor}
            />
            <div
              style={{
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                flexDirection: "column",
              }}
            >
              <EditNameInput
                label="Enter category name"
                placeholder="Enter category name"
                value={editName}
                error={editNameError !== "" || editName.length === 0}
                onChange={handleEditNameChange}
                helperText={
                  editNameError
                    ? editNameError
                    : editName.length === 0
                    ? "Category name is required"
                    : `${editName.length}/${CATEGORY_NAME_MAX_LENGTH}`
                }
              />
              <ColorPicker
                color={editColor}
                width="300px"
                fontColor={theme.darkmode ? ColorPalette.fontLight : ColorPalette.fontDark}
                onColorChange={(clr) => {
                  setEditColor(clr);
                }}
              />
            </div>
          </DialogContent>
          <DialogActions>
            <DialogBtn onClick={handleEditDimiss}>Cancel</DialogBtn>
            <DialogBtn
              onClick={handleEditCategory}
              disabled={editNameError !== "" || editName.length === 0}
            >
              <SaveRounded /> &nbsp; Save
            </DialogBtn>
          </DialogActions>
        </Dialog>
      </CategoriesContainer>
    </>
  );
};

export default Categories;


// File: workspace/TodoApp/src/services/bmcApi.ts
import { showToast } from "../utils";

interface BMCResponse {
  supportersCount: number;
}
/**
 * Function to fetch data from the Buy Me a Coffee API
 * @returns Number of buy me a coffee supporters.
 */
export const fetchBMCInfo = async (): Promise<BMCResponse> => {
  const username = "maciekt07";
  const url = `https://img.buymeacoffee.com/button-api/?&slug=${username}`;
  try {
    // Fetch data from the provided URL
    const response = await fetch(url);
    const html = await response.text();
    // Parse the HTML response using DOMParser
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");
    // Find the element containing the number of supporters
    const supportersCountElement = doc.querySelector("text[x='226'][y='39'][text-anchor='middle']");
    if (supportersCountElement) {
      const supportersCount = Number(supportersCountElement.textContent);
      return { supportersCount };
    } else {
      throw new Error("Failed to fetch Buy Me a Coffee API: Supporters count element not found.");
    }
  } catch (error) {
    console.error("Error fetching Buy Me a Coffee API:", error);
    navigator.onLine &&
      showToast("Failed to fetch Buy Me a Coffee API.", { type: "error", disableVibrate: true });
    return { supportersCount: 0 };
  }
};


// File: workspace/TodoApp/src/services/githubApi.ts
import type { GitHubBranchResponse, GitHubInfoResponse, GitHubRepoResponse } from "../types/github";
import { showToast } from "../utils";

/**
 * Function to fetch GitHub repository and branch information.
 * @returns {Promise<GitHubInfoResponse>} Promise that resolves to an object containing repository and branch data.
 */
export const fetchGitHubInfo = async (): Promise<GitHubInfoResponse> => {
  const username = "maciekt07";
  const repo = "TodoApp";
  const branch = "main";

  try {
    const [repoResponse, branchResponse] = await Promise.all([
      fetch(`https://api.github.com/repos/${username}/${repo}`),
      fetch(`https://api.github.com/repos/${username}/${repo}/branches/${branch}`),
    ]);

    if (repoResponse.ok && branchResponse.ok) {
      const [repoData, branchData] = await Promise.all([
        repoResponse.json() as Promise<GitHubRepoResponse>,
        branchResponse.json() as Promise<GitHubBranchResponse>,
      ]);
      return {
        repoData,
        branchData,
      };
    } else {
      // Check if rate limit exceeded
      if (repoResponse.status === 403 && branchResponse.status === 403) {
        showToast("Github API rate limit exceeded temporarily for your IP address.", {
          type: "error",
          disableVibrate: true,
        });
      } else {
        throw new Error("Failed to fetch repository or branch information");
      }
    }
  } catch (error) {
    console.error(error);
    navigator.onLine &&
      showToast("Failed to fetch Github API.", { type: "error", disableVibrate: true });
  }
  // Return a default value in case of error
  return { repoData: {} as GitHubRepoResponse, branchData: {} as GitHubBranchResponse };
};


